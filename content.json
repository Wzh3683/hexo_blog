{"meta":{"title":"WZH的博客","subtitle":"","description":"","author":"王增辉","url":"http://www.okwzh.cn","root":"/"},"pages":[{"title":"所有分类","date":"2020-06-05T11:00:44.079Z","updated":"2020-06-05T11:00:44.079Z","comments":false,"path":"categories/index.html","permalink":"http://www.okwzh.cn/categories/index.html","excerpt":"","text":""},{"title":"秃顶程序员plus","date":"2020-06-04T11:58:30.938Z","updated":"2020-06-04T11:58:30.938Z","comments":false,"path":"friends/index.html","permalink":"http://www.okwzh.cn/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-28T12:12:33.000Z","updated":"2020-06-05T11:12:12.753Z","comments":false,"path":"about/index.html","permalink":"http://www.okwzh.cn/about/index.html","excerpt":"","text":"————————————————————————————————————————————————————————————————————————————————————————————————— *基本信息王增辉 1998年4月 北京 Python全栈开发工程师 3年工作经验 手机：13383913683 邮箱：1018653578@qq.com 个人网站：http://www.okwzh.cn—————————————————————————————————————————————————————————————————————————————————————————————————*个人简介三年Python全栈开发经验，掌握Django框架，作为主力工程师参与设计于开发过多个项目，负责系统核心模块的开发，测试与自动化部署，由高并发WEB应用框架经验。掌握爬虫技术，熟练使用Scrapy，熟悉前端业务规范，掌握vue.js开发，掌握websocket，掌握MySQL,redis，MongoDB数据库与LINux系统的常见机制与原理。由优秀的学习能力与团队沟通能力，经常与团队进行技术分享，能与团队共同成长。—————————————————————————————————————————————————————————————————————————————————————————————————*教育经历2012.08 - 2016.06 北京电子科技大学通信工程学院 统招一本—————————————————————————————————————————————————————————————————————————————————————————————————*技能列表● 后端框架：Django，Flask，Scrapy ● 前端：Vue.js,axios,jquery,node.js ● 前端框架：Vue.js，Node.js ● 数据库：MySQL , redis , MongoDB ● 工具：Git,Docker,Postman ● 编译器：PyCharm,Visual Studio Code,Sublime Text—————————————————————————————————————————————————————————————————————————————————————————————————*工作经历● 2017年9月 - 2019年5月 北京谐云科技有限公司—初级python开发工程师 ● 2019年7月 - 至今 北京微点网络科技有限公司—高级全栈开发工程师—————————————————————————————————————————————————————————————————————————————————————————————————*近期参与项目主导北京谐云科技跨境移动聚合支付平台开发● 搭建基于Docker挂载Nginx-rtmp的直播服务器 ● 使用FFmpeg利用客户端设备进行推流，对视频进行头图提取，精华片段转换动图，视频埋点，视频信息分析等操作 ● 开发，测试点播，直播，播单等7个模块 ● 采用FastDfs分布式文件系统作为海量视频存储方案，利用视频指纹规避重复文件问题,节约了大约20%的硬盘空间 ● 在网页端使用vue.js作为载体利用video.js作为直播流播放器，优化延迟达到500ms左右 ● 利用Nginx反向代理后台uwsgi+Django的点播接口，并且针对性使用Nginx负载均衡策略 ● 使用Bootstrap作为播放页响应式设计解决方案，一套代码自适应大小屏应用，降低了50%左右的移动端开发成本 ● 利用协同过滤算法针对用户和视频两个维度分别画像，定制视频精准推荐系统 主导北京谐云科技跨境移动聚合支付平台开发● 基于Django实现Restful风格的在线聚合支付接口，聚合封装了支付宝，微信，京东等三方支付平台 ● 使用Mysql存储数据，配置主从热备，使用Celery实现异步邮箱和短信推送 ● 利用Websocket实现后端消息主动推送，改造前端传统轮询技术框架，减少了30%的网络请求数，节约了大约一半的可用带宽 ● 使用Redis作为缓存介质，利用其分布式锁和队列的特性开发并测试抢单秒杀功能 ● 开发，测试登录/注册，订单，支付/退款等7个模块"},{"title":"关于","date":"2020-06-05T11:35:31.222Z","updated":"2020-06-05T11:35:31.222Z","comments":true,"path":"comments/index.html","permalink":"http://www.okwzh.cn/comments/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-28T12:08:01.000Z","updated":"2020-05-28T12:11:47.932Z","comments":false,"path":"tags/index.html","permalink":"http://www.okwzh.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"'VOLANTIS博客的搭建'","slug":"VOLANTIS博客的搭建","date":"2020-06-05T07:30:08.000Z","updated":"2020-06-05T13:46:19.416Z","comments":true,"path":"2020/06/05/VOLANTIS博客的搭建/","link":"","permalink":"http://www.okwzh.cn/2020/06/05/VOLANTIS%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置","text":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置 配置博客主题为VOLANTIS123#在站点配置_config.yml中修改blog/_config.ymltheme: volantis 配置博客主题标题123#在站点配置_config.yml中修改blog/_config.ymltitle: 你博客主题名称 front-matter12345678---cover: true/false #设置封面------ #参考资料references: - name: Apple Developer Documentation url: https://developer.apple.com/documentation/---","categories":[],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://www.okwzh.cn/tags/hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"'jieba库的安装使用'","slug":"jieba库的安装使用","date":"2020-06-04T03:00:26.000Z","updated":"2020-06-04T03:07:58.657Z","comments":true,"path":"2020/06/04/jieba库的安装使用/","link":"","permalink":"http://www.okwzh.cn/2020/06/04/jieba%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"jieba库的安装 1pip install jieba","text":"jieba库的安装 1pip install jieba jieba库的使用12345678910111213141516171819202122232425262728293031323334import jieba.analysedata = \"Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。\" \\ \"Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。\"#提取标签for keyword,weight in jieba.analyse.extract_tags(data,withWeight=True): print('%s:%s' % (keyword,weight))#输出内容# Building prefix dict from the default dictionary ...# Loading model from cache C:\\Users\\10186\\AppData\\Local\\Temp\\jieba.cache# Loading model cost 0.878 seconds.# Prefix dict has been built successfully.# Python:1.1385492859904762# 数据类型:0.585297130452381# Guido:0.5692746429952381# van:0.5692746429952381# Rossum:0.5692746429952381# 1989:0.5692746429952381# 1991:0.5692746429952381# 发行版:0.5270221099# 面向对象:0.5067895768571429# 程序设计:0.44264321266619044# 发明:0.31970364912190474# 动态:0.3195238865542857# 高级:0.3114256070914286# 语言:0.29349988448285713# 第一个:0.28425680430714284# 解释:0.2720391527752381# 年底:0.2701318006847619# 公开:0.26735277138999997# 发行:0.22793990734714284# 一种:0.19674458076142856","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'无限极分类'","slug":"无限极分类","date":"2020-06-03T12:19:22.000Z","updated":"2020-06-03T12:51:18.600Z","comments":true,"path":"2020/06/03/无限极分类/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/","excerpt":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样.","text":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样. 无限极分类 12345678910衣服 上衣 短袖 卫衣 裤子 牛仔裤 休闲裤 鞋子 运动鞋 休闲鞋 无限极分类应用场景很广泛，例： 帖子的回复功能 课程的目录章节 基于python,结合django+vue实现无限极分类(递归层级结构)在myapp中model.py文件下 123456789class Cate(models.Model): #id是主键，自增 #分类名称 name = models.CharField(max_length=200,null=True) #父级分类id pid = models.IntegerField() class Meta: db_table = 'cate' 数据库配置数据 使用drf框架进行序列化 123456789#导包from rest_framework import serializersfrom .models import Cate#序列化类class CateSer(serializers.ModelSerializer): class Meta: model = Cate fields = '__all__' 写一个用来进行递归的方法，进行层级结构划分 12345678910111213141516def Xtree(datas): lists = [] tree = &#123;&#125; for item in datas: tree[item['id']] = item print(tree[item['id']]) for i in datas: if not i['pid']: root = tree[i['id']] lists.append(root) else: parent_id = i['pid'] if 'child' not in tree[parent_id]: tree[parent_id]['child'] = [] tree[parent_id]['child'].append(tree[i['id']]) return lists 写视图接口并分配路由 123456789101112from .myser import CateSerfrom .cengji import Xtree# 递归层级分类class MyTree(APIView): def get(self,request): cates = Cate.objects.all() ser = CateSer(cates,many=True) trees = Xtree(ser.data) return Response(trees)#分配url# path('tree/',MyTree.as_view()), 测试接口 前端使用递归组件渲染所谓递归组件: 就是组件可以在它们自己的模板中调用自身，不过它们只能通过 name 选项来做这件事，例如给组件设置属性 name: ‘Reply’，然后在模板中就可以使用 Reply 调用自己进行递归调用了 设置Reply.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;li&gt; &lt;div :class=\"[data.id==0 ? 'root':'','reply']\"&gt; &#123;&#123;data.name&#125;&#125; &lt;/div&gt; &lt;ul v-if=\"data.child &amp;&amp; data.child.length&gt;0\"&gt; &lt;Reply v-for=\"c in data.child\" :key=\"c.id\" :data=\"c\"&gt;&lt;/Reply&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:\"Reply\",//递归需要设置name属性，才能在模板中调用自身 data()&#123; return&#123; &#125; &#125;, props:['data'], mounted() &#123; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.reply&#123; padding-left: 4px; border-left: 1px solid #eee;&#125;ul&#123; padding-left: 20px; list-style: none;&#125;.root&#123; display: none;&#125;&lt;/style&gt; 在其他组件调用Reply.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- import cengji from '@/components/cengji'&#123; path:'/cengji', name:'cengji', component:cengji&#125;, --&gt;&lt;template&gt; &lt;div&gt; &lt;Reply :data=\"data\"&gt;&lt;/Reply&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// import &#123;config,formatXml&#125; from '../config'// import mh_test from './mh_test.vue'import Reply from './Reply'// import md5 from 'js-md5'export default &#123; data()&#123; return&#123; data:&#123;&#125;, online:0, &#125; &#125;, components:&#123; Reply &#125;, mounted() &#123; this.get_token() &#125;, methods: &#123; get_token()&#123; this.axios(&#123; url:\"http://localhost:8000/tree/\", method:\"GET\" &#125;).then(resp=&gt;&#123; console.log(resp) var tree = &#123;'id':0,name:\"123\"&#125; tree['child'] = resp.data this.data = tree console.log(this.data) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.on &#123; background: #cdcbff;&#125;.off &#123;background: #fefdff;&#125;&lt;/style&gt; 前端结果展示","categories":[],"tags":[]},{"title":"'算法-斐波那契数列'","slug":"算法-斐波那契数列","date":"2020-06-03T07:39:35.000Z","updated":"2020-06-03T07:58:49.369Z","comments":true,"path":"2020/06/03/算法-斐波那契数列/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）","text":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 递归斐波那契数列(写法最简洁，但是效率最低，会出现大量的重复计算，时间复杂度O（1.618^n）,而且最深度1000) 12345678910def fib_func(n): # 定义出口 if n &lt;= 1: return 1 return func(n-1)+func(n-2) #第一位数和第二位数相加的结果for i in range(10): print(fib_func(i),end=\" \")#1 1 2 3 5 8 13 21 34 55 生成器斐波那契数列带有yield的函数都被看成生成器，生成器是可迭代对象，且具备iter 和 next方法， 可以遍历获取元素python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现iter方法，而iter方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的iter方法返回自身即可 1234567891011def fib_func(max): n,a,b = 0,0,1 while n &lt; max: yield b a,b = b,a+b n += 1fib_list = fib_func(10)for i in fib_list: #使用for循环遍历 print(i,end=\" \")#1 1 2 3 5 8 13 21 34 55","categories":[],"tags":[]},{"title":"'python算法'","slug":"python算法","date":"2020-06-03T07:22:27.000Z","updated":"2020-06-03T07:37:09.140Z","comments":true,"path":"2020/06/03/python算法/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/python%E7%AE%97%E6%B3%95/","excerpt":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。","text":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。 常用排序算法： 1234567冒泡排序(*****)选择排序(*****)插入排序快速排序希尔排序归并排序堆排序 搜索是在一个项目集合中找到一个特定项目的算法过程。 常用排序算法： 1234顺序查找二分法查找（*****）二叉树查找哈希查找","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'递归算法'","slug":"递归算法","date":"2020-06-03T01:39:25.000Z","updated":"2020-06-03T02:44:40.904Z","comments":true,"path":"2020/06/03/递归算法/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","excerpt":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?…","text":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?… 什么是函数嵌套调用？什么是递归？123函数内部是可以调用其他函数的，这种调用就是函数的嵌套调用。递归就是&#39;函数在内部直接或间接调用自己本身&#39;。 使用递归的注意事项123451.必须有明确的退出条件2.每次进入更深一层递归时，问题规模比上次递归都有所减少3.递归到一定层次就会出现结果4.递归效率不高，递归层数过多会导致栈溢出(栈内存不够用)5.栈溢出默认是1000,但是当递归到998就已经报错了。 栈溢出错误：1栈溢出错误：RecursionError: maximum recursion depth exceeded in comparison 解决栈溢出的办法：123#修改递归深度的值import syssys.setrecursionlimit(2000) 关于栈溢出例子：12345678import syssys.setrecursionlimit(2000) #设置最大递归深度是2000def sum_digui_func(n): if n &lt;= 0: return 0 return n + sum_digui_func(n-1)#当我们运行到1997是，还是可以运行的。到1998就报错，所以可以认为比设置最大递归深度-3就是可以运行的。print(sum_digui_func(1997)) 说到递归就要说下逆向思维，在大部分情况下，人们所想的是都是片面，也就是有局限性。逆向思维就是突破这个局限性，从另一方面去想怎么解决这个事情。 逆向思维小故事 1234关于司马光砸缸： 讲述了司马光砸坏水缸，救出同伴的古诗。 在大部分情况下的人，当时所想的是如何让人脱离水，从而救出人。 我们通过逆向思维，想到也可以使水脱离人，从而脱救，于是把水缸砸坏，使水流光从而进行救助。 递归求和 1234567def sum_func(n): #设定出口，退出条件 if n &lt;= 0: return 0 #调用自身，每次和自身-1相加 return n + sum_func(n-1)print(sum_func(5)) 阶乘 1234567def ride_func(n): #设定出口，退出条件 if n &lt;= 1: return 1 #调用自身，每次和自身-1相乘 return n + ride_func(n-1)print(ride_func(5))","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'设计模式之工厂模式'","slug":"设计模式之工厂模式","date":"2020-06-02T08:34:10.000Z","updated":"2020-06-02T11:18:57.349Z","comments":true,"path":"2020/06/02/设计模式之工厂模式/","link":"","permalink":"http://www.okwzh.cn/2020/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。","text":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。 简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。简单工厂实例化的类具有相同的接口或者基类，在子类比较固定并不需要扩展时，可以使用简单工厂。如数据库生产工厂就是简单工厂的一个应用采用简单工厂的优点是可以使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性；缺点是可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂，不符合OCP（开闭原则）的原则。简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。 与django结合实现工厂模式 12345678910111213141516171819202122232425262728293031323334class WeiBo: def __repr__(self): return '使用微博进行第三方登录'class DingDing: def __repr__(self): return '使用钉钉进行第三方登录'class Gitee: def __repr__(self): return '使用马云进行第三方登录'#实例化类weibo = WeiBo()dingding = DingDing()gitee = Gitee()#简单工厂模式class Factory: #这里使用静态方法 @staticmethod def Login(name): if name == 'weibo': return WeiBo() elif name == 'dingding': return DingDing() elif name == 'gitee': return Gitee()factory = Factory.Login(\"weibo\")#当name==weibo，输出使用微博进行第三方登录#当name==dingding，输出使用使用钉钉进行第三方登录#当name==gitee，输出使用马云进行第三方登录print(factory)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'schedule的定时任务'","slug":"celery的定时任务","date":"2020-06-01T06:44:33.000Z","updated":"2020-06-02T11:18:18.841Z","comments":true,"path":"2020/06/01/celery的定时任务/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/celery%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"使用定时任务定时执行","text":"使用定时任务定时执行 启动定时任务命令 12在和manage.py文件同级目录下： celery -A mydjango beat -l info 注意： 1234启动定时任务需要启动三个服务1.django后台服务：python manage.py runserver2.selery后台服务：celery worker -A mydjango -l info -P eventlet3.定时任务服务：celery -A mydjango beat -l info 启动定时任务出现错误 12ERROR: Pidfile (celerybeat.pid) already exists.Seems we're already running? (pid: 29396) 这个错误就是说启动服务的文件夹里有启动文件celerybeat.pid了，把他删掉就可以了，记得再次重启 在settings中配置12345678910111213#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称,解析字符串寻找 'schedule':timedelta(seconds=7200) #定时时长 &#125;&#125; 结合Django使用一个小案例：每1分钟提交一次log文件12345678910111213141516171819202122232425262728在settings配置#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称 'schedule':timedelta(seconds=60) #定时时长，,1分钟 &#125;&#125;创建一个task.py文件from celery.task import task#自定义异步任务@taskdef async_test(): print('异步任务') #文件名 filename = 'celeray.log' #追加形式写入 with open(filename,'a') as f: #写入文件时间 f.write(str(datetime.datetime.now())+'\\n') return '123123'","categories":[],"tags":[{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"}]},{"title":"'关于使用selery出现错误的问题'","slug":"关于使用selery出现错误的问题","date":"2020-06-01T03:38:28.000Z","updated":"2020-06-02T09:10:00.582Z","comments":true,"path":"2020/06/01/关于使用selery出现错误的问题/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8selery%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"启动celery命令 1celery worker -A celery_task -l info -P eventlet","text":"启动celery命令 1celery worker -A celery_task -l info -P eventlet 在django中使用restful风格做开发时，发现都不能发送在使用post方法的时候，因为我的celery后台一直是启动的，所以不运行task中封装的函数，然后一直在找解决办法，于是我重启celery后台，会出现一个错误 该错误描述： 1TypeError: wrap_socket() got an unexpected keyword argument '_context' 于是找了解决办法，换个启动命令request包的request.post发送后，传不回数据 所以，在改变服务器启动方法不要用eventlet，加个参数 1celery worker -A mydjango -l info -P=solo 来源: Apical转载于: https://www.sirxs.cn/2020/06/01/Note/celery_error/","categories":[],"tags":[]},{"title":"'celery异步的使用'","slug":"celery异步的使用","date":"2020-06-01T01:23:44.000Z","updated":"2020-06-02T09:10:16.863Z","comments":true,"path":"2020/06/01/celery异步的使用/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/celery%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2","text":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2 django配置celery在settings中配置123456#代理url，异步任务代理CELERY_BROKER_URL = 'redis://localhost:6379/'#保存结果CELERY_RESULT_BACKEND = 'redis://localhost:6379/'#保存类型格式，使用jsonCELERY_RESULT_SERIALIZER = 'json' 在和settings同一级目录下，创建celery.py文件，进行配置文件，用来启动服务123456789101112131415# -*- coding: utf-8 -*-from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery# 设置环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mydjango.settings')# 注册Celery的APPapp = Celery('mydjango')# 绑定配置文件,声明命名空间,可以在电脑任何位置启动app.config_from_object('django.conf:settings', namespace='CELERY')# 自动发现各个app下的tasks.py文件app.autodiscover_tasks() 在和settings同一级目录下的init.py文件下，当启动服务，加载init.py文件配置12345678910from __future__ import absolute_import, unicode_literalsfrom .celery import app as celery_app#导包import pymysql#初始化pymysql.install_as_MySQLdb()#加载celery应用__all__ = ['celery_app'] 在myapp文件夹下，创建一个tasks.py文件，自定义任务123456789from celery.task import task#自定义异步任务#实用装饰器声明是异步任务@taskdef async_test(): print('异步任务') return '123123' 触发异步任务队列1234567#调用tasks异步from myapp import tasks#触发异步任务视图def celery_test(request): #使用delay()异步任务调用 res = tasks.async_test.delay() return JsonResponse(&#123;'task_id':res.task_id&#125;) 配置url12345from myapp.views import celery_testurlpatterns = [ #定义超链接路由 path('celery_test/',celery_test),] 启动celery服务1231.先启动django服务：python manage.py runserver2.在manage.py文件的同级目录下，启动celery服务3.以协程方式启动服务命令：celery worker -A mydjango -l info -P eventlet 实例:做邮件发送使用celery123456789101112131415161718192021222324252627282930313233343536373839404142#task中：from celery.task import taskfrom mydjango.settings import MY_MAIL,MY_PASSfrom email.mime.text import MIMETextfrom email.utils import formataddrimport smtplib@taskdef mail(subject,content,mailaddr): #声明邮件对象 msg = MIMEText(content,'plain','utf-8') #设置发送方对象 msg['From'] = formataddr(['在线教育平台',MY_MAIL]) #设置收件方对象 msg['To'] = formataddr(['尊敬的客户',mailaddr]) #设置标题 msg['Subject'] = subject #设置smtp服务器 server = smtplib.SMTP_SSL('smtp.qq.com',465) #登录邮箱 server.login(MY_MAIL,MY_PASS) #发送邮件 server.sendmail(MY_MAIL,[mailaddr],msg.as_string()) #关闭smtp连接，节约系统资源 server.quit()#退出#在视图中class Register(APIView): def post(self,request): email = request.data.get('email') #获取前端用户邮件 subject = '亲爱的用户您好：,欢迎注册在线教育平台' #邮件标题 yanzhengma = random.randint(1000,9999) print(yanzhengma) #数字验证码 r.set('email',yanzhengma,120) #存到redis print(123,r.get('email')) content = '欢迎注册在线教育平台，您的验证码是%s，请在2分钟内输入，失效请重新获取' % yanzhengma print(content) #邮件内容 mailaddr = email #给发送邮件 #参数需要存放到delay(里) send_email = tasks.mail.delay(subject, content, mailaddr) #异步发送邮件调用邮件 #使用celery需要使用JsonResponse返回 return JsonResponse(&#123;'code':200,'yzm':yanzhengma,'send_email':send_email.task_id&#125;)","categories":[],"tags":[{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"}]},{"title":"git","slug":"git","date":"2020-05-31T05:10:10.000Z","updated":"2020-06-04T05:09:00.090Z","comments":true,"path":"2020/05/31/git/","link":"","permalink":"http://www.okwzh.cn/2020/05/31/git/","excerpt":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。","text":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。 Git的下载与安装1git的下载与安装:https:&#x2F;&#x2F;blog.csdn.net&#x2F;Dan_Xiao_Hui&#x2F;article&#x2F;details&#x2F;105637182 在Gitee上创建仓库12345678910111213141516171819202122232425在Gitee上创建仓库： 1.点击+号，新建仓库，如图1, 2.编辑仓库名，仓库路径，仓库描述，公开 3.点击创建创建git仓库： 1.创建一个文件夹cangku:mkdir cangku 2.进入文件夹：cd cangku 3.初始化git：git init 4.将要上传的文件添加到暂存区：git add -A 5.将暂存区文件提交到仓库：git commit -m &#39;描述&#39; 6.因为是第一次上传，所以需要确定好gitee的git仓库： git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;wang_zeng_hui&#x2F;cangku.git #####只有第一次上传，需要确定Git仓库位置，以后不需要 7.推送到云端：git push -u origin master需要用户名或密码：(只需要写入一次)(图4) git config --global user.name &quot;你登录gitee的名字&quot; git config --global user.email &quot;你登录的email&quot;删除仓库： 1.进入管理(如图5) 2.点击删除仓库(如图6) 3.根据要求输入内容(如图7) 4.登录账号,进行验证(如图8) 图1 图2 图3 图4 删除仓库图5 图6 图7 图8 Git的命令1234567891011121314Git的常用命令： 1.将线上网址克隆到本地：git clone git网址 2.将工作区的修改添加到暂存区：git add -A 3.将暂存区的文件提交到仓库：git commit -m &#39;描述&#39; 4.将仓库推送到云端：git push origin master其他命令： 清掉配置：git config --system --unset credential.helper 保存密码：git config --global credential.helper store 查看版本日志：git log 简单日志：git log --pretty&#x3D;oneline 回退操作：git reset --hard &#39;版本号&#x2F;日志&#39; 回退之后返回之前操作日志：git reflog git reset --hard &#39;版本号&#x2F;日志&#39; Git的分支命令123456789101112131415在我们每次提交之后都会有记录，Git把它们穿成时间线，形成类似于时间轴的东西。这个时间轴就是一个分支，我们称之为master分支。分支相关命令： 查看分支：git branch 查看所有分支：git branch -a 查看远端分支：git branch -r 创建并切换分支：git checkout -b 分支名 建立本地与线上分支关联：git push --set-upstream origin 分支名(可以不切换分支就能提交) 创建分支：git branch 分支名 切换分支：git checkout 分支名 合并分支：git merge 被合并的分支名（需要先切换到master分支） 删除分支：git branch -d 分支名 删除远程分支：git push origin --delete 分支名 注意：当我们进行删除分支的时候，注意要先退出要删除的分支，不然会报错。 Git的合并1234561.创建dev分支：git checkout -b dev2.将本地分支提交线上：git push --set-upstream origin dev3.切换master分支：git checkout master4.合并分支：git merge dev(直接push提交，不需要推送)5.合并之后推送到线上：git push origin master","categories":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/tags/git/"}]},{"title":"项目目录","slug":"day02项目目录","date":"2020-04-20T23:55:29.000Z","updated":"2020-06-02T09:05:19.935Z","comments":true,"path":"2020/04/21/day02项目目录/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/","excerpt":"vue有关项目目录","text":"vue有关项目目录 vue的项目目录1234567891011121314151617181920212223build:打包文件config:配置文件 dev.env.js:开发环境变量 index.js:生产环境变量 prod.env.js:灰度环境dist:打包之后存放的文件node_modules:安装的依赖，配置文件,基于package.json下载(该文件不能提交到仓库,需要加入.gitignore).gitignore:存放不需要上传仓库的文件package.json:读取存放依赖，配置等信息 heyui:网页样式 js-mds:加密 style-loader:样式 vue:vue本体 vue-drag-verify:验证码 vue-router:路由components:组件文件夹router&#x2F;index.js:路由 path：路径url name：命名空间 components:导包组件 mode：&#39;history&#39; 取消hash风格的#App.vue：渲染组件main.js：入口文件，vue的组件，实例等都存在这里 hugo的项目目录123456789101112131415161718archetypes:文本配置文件content:生成的md文档data:数据文件夹layouts:布局public:打包文件resources:资源static:静态文件thems:主题config.homl:网站配置文件 baseURL:线上&#x2F;线下url languageCode:语言 title:标题 theme:主题 params：简介和描述 description:简介 themColor:博客主题颜色修改主题颜色：在themes--&gt;hyde--&gt;static--&gt;css--&gt;hyde.css中改颜色(可以自定义主题和颜色)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]},{"title":"Vue启动和命令","slug":"day02vue启动和命令","date":"2020-04-20T23:03:21.000Z","updated":"2020-06-02T09:11:22.987Z","comments":true,"path":"2020/04/21/day02vue启动和命令/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02vue%E5%90%AF%E5%8A%A8%E5%92%8C%E5%91%BD%E4%BB%A4/","excerpt":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0)","text":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0) 三大框架(三大框架都是基于node)1234567891011React： 1 自组件重复渲染问题需要手动优化 2 可以使用redux进行状态管理，函数式，不可变，模式化，时间旅行 3 可使用JSX，完全的javascript能力 4更繁荣的社区生态Vue： 1 可使用JSX，但推荐使用模版语言而不是JSX 2 学习曲线平缓Angular： 1 完善的MV框架，包含模版，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能 2 typescript 3 脏检查，对脏数据的检查，比较UI和后台的数据是否一致 安装依赖(npm)12345678910111213npm： 1.npm官网：https:&#x2F;&#x2F;www.npmjs.com&#x2F; 2.下载安装npm 3.给npm配置环境变量检查npm： 命令：npm -v (6.14.4)关于npm命令： 1.npm默认源是github，因为是外网，所以我们要改源（淘宝源）。命令： npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org 2.查看npm配置：npm config list 3.当npm版本过低，更新版本：npm install -g npm vue1234567891011121314151617181920vue的中文文档：https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html关于vue命令： 1.清空本地缓存：npm cache clean --force 1.在vue中安装依赖&#x2F;配置文件：npm install 2.启动vue：npm run dev 退出：ctrl+cvue依赖： npm install axios --save npm install style-loader —-save npm install heyui --save npm install js-md5 --save关于vue服务启动失败： 1.关掉命令行，退到上一级目录，手动删除node_modules,然后npm install 2.下载rimarf命令：npm install rimraf -g 删除node_modules命令：rimraf node_modules (图2) #使用前提，npm需要是新版本 #优先使用第二个理由：第一个手动删除需要花费大量时间，删除进度缓慢","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]},{"title":"环境变量的配置","slug":"day02环境变量","date":"2020-04-20T18:58:38.000Z","updated":"2020-06-02T09:14:40.885Z","comments":true,"path":"2020/04/21/day02环境变量/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"环境变量的配置1.找到此电脑","text":"环境变量的配置1.找到此电脑 2.点击右键–&gt;属性 3.点击高级系统设置 4.点击环境变量 5.选择用户变量或者系统变量，点击path，点击编辑 6.点击新建，然后输入需要配置环境变量的路径，一般情况下在bin目录（或者在cmd下） 7.编辑好路径之后，点击确定，再点击确定。然后退出环境变量，确保更改成功。8.ok","categories":[],"tags":[]}],"categories":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/categories/git/"}],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://www.okwzh.cn/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"},{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/tags/git/"},{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]}