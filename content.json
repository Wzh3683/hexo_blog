{"meta":{"title":"WZH的博客","subtitle":"","description":"","author":"王增辉","url":"http://www.okwzh.cn","root":"/"},"pages":[{"title":"所有分类","date":"2020-06-05T11:00:44.079Z","updated":"2020-06-05T11:00:44.079Z","comments":false,"path":"categories/index.html","permalink":"http://www.okwzh.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-05T11:35:31.222Z","updated":"2020-06-05T11:35:31.222Z","comments":true,"path":"comments/index.html","permalink":"http://www.okwzh.cn/comments/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-28T12:12:33.000Z","updated":"2020-06-06T05:35:11.957Z","comments":false,"path":"about/index.html","permalink":"http://www.okwzh.cn/about/index.html","excerpt":"","text":"————————————————————————————————————————————————————————————————————————————————————————————————— *基本信息王增辉 1998年4月 北京 Python全栈开发工程师 3年工作经验 手机：13383913683 邮箱：1018653578@qq.com 个人网站：http://www.okwzh.cn—————————————————————————————————————————————————————————————————————————————————————————————————*个人简介三年Python全栈开发经验，掌握Django框架，作为主力工程师参与设计于开发过多个项目，负责系统核心模块的开发，测试与自动化部署，由高并发WEB应用框架经验。掌握爬虫技术，熟练使用Scrapy，熟悉前端业务规范，掌握vue.js开发，掌握websocket，掌握MySQL,redis，MongoDB数据库与LINux系统的常见机制与原理。由优秀的学习能力与团队沟通能力，经常与团队进行技术分享，能与团队共同成长。—————————————————————————————————————————————————————————————————————————————————————————————————*教育经历2012.08 - 2016.06 北京电子科技大学通信工程学院 统招一本—————————————————————————————————————————————————————————————————————————————————————————————————*技能列表● 后端框架：Django，Flask，Scrapy ● 前端：Vue.js,axios,jquery,node.js ● 前端框架：Vue.js，Node.js ● 数据库：MySQL , redis , MongoDB ● 工具：Git,Docker,Postman ● 编译器：PyCharm,Visual Studio Code,Sublime Text—————————————————————————————————————————————————————————————————————————————————————————————————*工作经历● 2017年9月 - 2019年5月 北京谐云科技有限公司—初级python开发工程师 ● 2019年7月 - 至今 北京微点网络科技有限公司—高级全栈开发工程师—————————————————————————————————————————————————————————————————————————————————————————————————*近期参与项目主导北京谐云科技跨境移动聚合支付平台开发● 搭建基于Docker挂载Nginx-rtmp的直播服务器 ● 使用FFmpeg利用客户端设备进行推流，对视频进行头图提取，精华片段转换动图，视频埋点，视频信息分析等操作 ● 开发，测试点播，直播，播单等7个模块 ● 采用FastDfs分布式文件系统作为海量视频存储方案，利用视频指纹规避重复文件问题,节约了大约20%的硬盘空间 ● 在网页端使用vue.js作为载体利用video.js作为直播流播放器，优化延迟达到500ms左右 ● 利用Nginx反向代理后台uwsgi+Django的点播接口，并且针对性使用Nginx负载均衡策略 ● 使用Bootstrap作为播放页响应式设计解决方案，一套代码自适应大小屏应用，降低了50%左右的移动端开发成本 ● 利用协同过滤算法针对用户和视频两个维度分别画像，定制视频精准推荐系统 主导北京谐云科技跨境移动聚合支付平台开发● 基于Django实现Restful风格的在线聚合支付接口，聚合封装了支付宝，微信，京东等三方支付平台 ● 使用Mysql存储数据，配置主从热备，使用Celery实现异步邮箱和短信推送 ● 利用Websocket实现后端消息主动推送，改造前端传统轮询技术框架，减少了30%的网络请求数，节约了大约一半的可用带宽 ● 使用Redis作为缓存介质，利用其分布式锁和队列的特性开发并测试抢单秒杀功能 ● 开发，测试登录/注册，订单，支付/退款等7个模块"},{"title":"秃顶程序员plus","date":"2020-06-06T05:29:45.168Z","updated":"2020-06-06T05:29:45.168Z","comments":false,"path":"friends/index.html","permalink":"http://www.okwzh.cn/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-28T12:08:01.000Z","updated":"2020-05-28T12:11:47.932Z","comments":false,"path":"tags/index.html","permalink":"http://www.okwzh.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"'结合百度ai实现自然语言分析'","slug":"结合百度AI实现自然语言分析","date":"2020-06-07T13:25:36.000Z","updated":"2020-06-07T13:49:49.045Z","comments":true,"path":"2020/06/07/结合百度AI实现自然语言分析/","link":"","permalink":"http://www.okwzh.cn/2020/06/07/%E7%BB%93%E5%90%88%E7%99%BE%E5%BA%A6AI%E5%AE%9E%E7%8E%B0%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"百度AI开放平台地址：点击跳转官方文档地址：点击跳转","text":"百度AI开放平台地址：点击跳转官方文档地址：点击跳转 获取应用1.进行注册登陆2.找到文字识别–&gt;应用列表3.创建应用4.获取AppID,API Key,Secret Key 安装百度AI模块 1pip install baidu-aip 对文本进行错误检查123456789101112131415from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#定义检查文本text = '学习python，学习人工只能'#进行检查res = client.ecnet(text)print(res)#&#123;'log_id': 9052624029983259239, 'item': &#123;'vec_fragment': [&#123;'ori_frag': '人工只能', 'begin_pos': 16, 'correct_frag': '人工智能', 'end_pos': 24&#125;], 'score': 0.590899, 'correct_query': '学习python，学习人工智能'&#125;, 'text': '学习python，学习人工只能'&#125; 对文本进行标签处理12345678910111213141516from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#标签title = 'python人工智能在线学习'content = '我再北京学习人工智能，他是基于python的一门学科'#调取标签res = client.keyword(title,content)print(res)#&#123;'log_id': 2174377746871861863, 'items': [&#123;'score': 0.9486, 'tag': '人工智能'&#125;, &#123;'score': 0.768706, 'tag': 'python'&#125;]&#125; 对文本进行情感分析12345678910111213from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#情感分析text = '华为是一家很棒的公司'print(client.commentTag(text))#&#123;'log_id': 1058331879559622439, 'items': [&#123;'sentiment': 2, 'abstract': '华为是一家很棒的公司&lt;span&gt;&lt;/span&gt;', 'prop': '感觉', 'begin_pos': 20, 'end_pos': 20, 'adj': '棒'&#125;]&#125;","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'第三方登录-gitee登录'","slug":"第三方登录-gitee登录","date":"2020-06-06T08:00:02.000Z","updated":"2020-06-06T08:36:09.287Z","comments":true,"path":"2020/06/06/第三方登录-gitee登录/","link":"","permalink":"http://www.okwzh.cn/2020/06/06/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-gitee%E7%99%BB%E5%BD%95/","excerpt":"创建gitee应用1.登陆gitee","text":"创建gitee应用1.登陆gitee gitee登录网站2.点击头像,设置,第三方应用3.创建应用4.自定义应用名称，应用描述，应用回调网址等。5.创建完成，获取Client ID,Client Secret,还有应用回调地址。 gitee开发文档开发文档地址：点击跳转 代码实例12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;img :src=\"'http://localhost:8000/static/mayun.png'\" alt=\"\" @click=\"gitee_login\" &gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, methods:&#123; //第三方登录--&gt;gitee登录 gitee_login()&#123; var client_id = '8778f21baf13e5a37d2d5d74b66dc74b2716d4f44d18bed2f08f02c229142812' var back = 'http://localhost:8000/gitee_back' var url = 'https://gitee.com/oauth/authorize?client_id='+client_id+'&amp;redirect_uri='+back+'&amp;response_type=code' window.location.href = url &#125;, &#125; &#125; 6.获取code来换取access_token 12345678910111213141516171819#gitee三方登录url: path('gitee_back',Gitee_Back.as_view()), #gitee回调class Gitee_Back(APIView): def get(self,request): code = request.GET.get('code') print(code) redirect_uri = 'http://localhost:8000/gitee_back' # url = 'https://gitee.com/oauth/authorize?client_id='+ CLIENT_ID +'&amp;redirect_uri=' + redirect_uri +'&amp;response_type=code' data = &#123; 'client_id':CLIENT_ID, 'client_secret':CLIENT_SECRET, 'redirect_uri':redirect_uri, 'code':code, 'grant_type': 'authorization_code' &#125; url = 'https://gitee.com/oauth/token?grant_type=authorization_code&amp;code='+code+'&amp;client_id='+ CLIENT_ID +'&amp;redirect_uri='+ redirect_uri +'&amp;client_secret='+CLIENT_SECRET res = requests.post(url=url,data=data) print(res.json()) 7.点击开发文档，API文档，用户账户，获取授权用户资料，申请授权 12345678910111213141516171819# 接上access_token = res.json()['access_token']#获取tokentoken_uri = 'https://gitee.com/api/v5/user?access_token=' +access_tokenres = requests.get(url=token_uri)print(res.json())user_id = ''username = str(res.json()['name'])user = User.objects.filter(username=username).first()if user: #表示曾经登陆过 user_id= int(res.json()['id']) user.username = username print('已经登录过,id是%s,名字是%s'%(user.id,user.username))else: user = User(username=username,id=int(res.json()['id']),password=make_password(\"\")) user.save() user_id = user.id print('第一次注册，id是%s,名字是%s'%(user.id,user.username))return redirect('http://localhost:8080/?user_id='+str(user_id)+'&amp;username='+username)","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'VOLANTIS博客的搭建'","slug":"VOLANTIS博客的搭建","date":"2020-06-05T07:30:08.000Z","updated":"2020-06-05T13:46:19.416Z","comments":true,"path":"2020/06/05/VOLANTIS博客的搭建/","link":"","permalink":"http://www.okwzh.cn/2020/06/05/VOLANTIS%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置","text":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置 配置博客主题为VOLANTIS123#在站点配置_config.yml中修改blog/_config.ymltheme: volantis 配置博客主题标题123#在站点配置_config.yml中修改blog/_config.ymltitle: 你博客主题名称 front-matter12345678---cover: true/false #设置封面------ #参考资料references: - name: Apple Developer Documentation url: https://developer.apple.com/documentation/---","categories":[],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://www.okwzh.cn/tags/hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"'jieba库的安装使用'","slug":"jieba库的安装使用","date":"2020-06-04T03:00:26.000Z","updated":"2020-06-04T03:07:58.657Z","comments":true,"path":"2020/06/04/jieba库的安装使用/","link":"","permalink":"http://www.okwzh.cn/2020/06/04/jieba%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"jieba库的安装 1pip install jieba","text":"jieba库的安装 1pip install jieba jieba库的使用12345678910111213141516171819202122232425262728293031323334import jieba.analysedata = \"Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。\" \\ \"Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。\"#提取标签for keyword,weight in jieba.analyse.extract_tags(data,withWeight=True): print('%s:%s' % (keyword,weight))#输出内容# Building prefix dict from the default dictionary ...# Loading model from cache C:\\Users\\10186\\AppData\\Local\\Temp\\jieba.cache# Loading model cost 0.878 seconds.# Prefix dict has been built successfully.# Python:1.1385492859904762# 数据类型:0.585297130452381# Guido:0.5692746429952381# van:0.5692746429952381# Rossum:0.5692746429952381# 1989:0.5692746429952381# 1991:0.5692746429952381# 发行版:0.5270221099# 面向对象:0.5067895768571429# 程序设计:0.44264321266619044# 发明:0.31970364912190474# 动态:0.3195238865542857# 高级:0.3114256070914286# 语言:0.29349988448285713# 第一个:0.28425680430714284# 解释:0.2720391527752381# 年底:0.2701318006847619# 公开:0.26735277138999997# 发行:0.22793990734714284# 一种:0.19674458076142856","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'无限极分类'","slug":"无限极分类","date":"2020-06-03T12:19:22.000Z","updated":"2020-06-03T12:51:18.600Z","comments":true,"path":"2020/06/03/无限极分类/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/","excerpt":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样.","text":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样. 无限极分类 12345678910衣服 上衣 短袖 卫衣 裤子 牛仔裤 休闲裤 鞋子 运动鞋 休闲鞋 无限极分类应用场景很广泛，例： 帖子的回复功能 课程的目录章节 基于python,结合django+vue实现无限极分类(递归层级结构)在myapp中model.py文件下 123456789class Cate(models.Model): #id是主键，自增 #分类名称 name = models.CharField(max_length=200,null=True) #父级分类id pid = models.IntegerField() class Meta: db_table = 'cate' 数据库配置数据 使用drf框架进行序列化 123456789#导包from rest_framework import serializersfrom .models import Cate#序列化类class CateSer(serializers.ModelSerializer): class Meta: model = Cate fields = '__all__' 写一个用来进行递归的方法，进行层级结构划分 12345678910111213141516def Xtree(datas): lists = [] tree = &#123;&#125; for item in datas: tree[item['id']] = item print(tree[item['id']]) for i in datas: if not i['pid']: root = tree[i['id']] lists.append(root) else: parent_id = i['pid'] if 'child' not in tree[parent_id]: tree[parent_id]['child'] = [] tree[parent_id]['child'].append(tree[i['id']]) return lists 写视图接口并分配路由 123456789101112from .myser import CateSerfrom .cengji import Xtree# 递归层级分类class MyTree(APIView): def get(self,request): cates = Cate.objects.all() ser = CateSer(cates,many=True) trees = Xtree(ser.data) return Response(trees)#分配url# path('tree/',MyTree.as_view()), 测试接口 前端使用递归组件渲染所谓递归组件: 就是组件可以在它们自己的模板中调用自身，不过它们只能通过 name 选项来做这件事，例如给组件设置属性 name: ‘Reply’，然后在模板中就可以使用 Reply 调用自己进行递归调用了 设置Reply.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;li&gt; &lt;div :class=\"[data.id==0 ? 'root':'','reply']\"&gt; &#123;&#123;data.name&#125;&#125; &lt;/div&gt; &lt;ul v-if=\"data.child &amp;&amp; data.child.length&gt;0\"&gt; &lt;Reply v-for=\"c in data.child\" :key=\"c.id\" :data=\"c\"&gt;&lt;/Reply&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:\"Reply\",//递归需要设置name属性，才能在模板中调用自身 data()&#123; return&#123; &#125; &#125;, props:['data'], mounted() &#123; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.reply&#123; padding-left: 4px; border-left: 1px solid #eee;&#125;ul&#123; padding-left: 20px; list-style: none;&#125;.root&#123; display: none;&#125;&lt;/style&gt; 在其他组件调用Reply.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- import cengji from '@/components/cengji'&#123; path:'/cengji', name:'cengji', component:cengji&#125;, --&gt;&lt;template&gt; &lt;div&gt; &lt;Reply :data=\"data\"&gt;&lt;/Reply&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// import &#123;config,formatXml&#125; from '../config'// import mh_test from './mh_test.vue'import Reply from './Reply'// import md5 from 'js-md5'export default &#123; data()&#123; return&#123; data:&#123;&#125;, online:0, &#125; &#125;, components:&#123; Reply &#125;, mounted() &#123; this.get_token() &#125;, methods: &#123; get_token()&#123; this.axios(&#123; url:\"http://localhost:8000/tree/\", method:\"GET\" &#125;).then(resp=&gt;&#123; console.log(resp) var tree = &#123;'id':0,name:\"123\"&#125; tree['child'] = resp.data this.data = tree console.log(this.data) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.on &#123; background: #cdcbff;&#125;.off &#123;background: #fefdff;&#125;&lt;/style&gt; 前端结果展示","categories":[],"tags":[]},{"title":"'算法-斐波那契数列'","slug":"算法-斐波那契数列","date":"2020-06-03T07:39:35.000Z","updated":"2020-06-03T07:58:49.369Z","comments":true,"path":"2020/06/03/算法-斐波那契数列/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）","text":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 递归斐波那契数列(写法最简洁，但是效率最低，会出现大量的重复计算，时间复杂度O（1.618^n）,而且最深度1000) 12345678910def fib_func(n): # 定义出口 if n &lt;= 1: return 1 return func(n-1)+func(n-2) #第一位数和第二位数相加的结果for i in range(10): print(fib_func(i),end=\" \")#1 1 2 3 5 8 13 21 34 55 生成器斐波那契数列带有yield的函数都被看成生成器，生成器是可迭代对象，且具备iter 和 next方法， 可以遍历获取元素python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现iter方法，而iter方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的iter方法返回自身即可 1234567891011def fib_func(max): n,a,b = 0,0,1 while n &lt; max: yield b a,b = b,a+b n += 1fib_list = fib_func(10)for i in fib_list: #使用for循环遍历 print(i,end=\" \")#1 1 2 3 5 8 13 21 34 55","categories":[],"tags":[]},{"title":"'python算法'","slug":"python算法","date":"2020-06-03T07:22:27.000Z","updated":"2020-06-03T07:37:09.140Z","comments":true,"path":"2020/06/03/python算法/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/python%E7%AE%97%E6%B3%95/","excerpt":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。","text":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。 常用排序算法： 1234567冒泡排序(*****)选择排序(*****)插入排序快速排序希尔排序归并排序堆排序 搜索是在一个项目集合中找到一个特定项目的算法过程。 常用排序算法： 1234顺序查找二分法查找（*****）二叉树查找哈希查找","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'递归算法'","slug":"递归算法","date":"2020-06-03T01:39:25.000Z","updated":"2020-06-03T02:44:40.904Z","comments":true,"path":"2020/06/03/递归算法/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","excerpt":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?…","text":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?… 什么是函数嵌套调用？什么是递归？123函数内部是可以调用其他函数的，这种调用就是函数的嵌套调用。递归就是&#39;函数在内部直接或间接调用自己本身&#39;。 使用递归的注意事项123451.必须有明确的退出条件2.每次进入更深一层递归时，问题规模比上次递归都有所减少3.递归到一定层次就会出现结果4.递归效率不高，递归层数过多会导致栈溢出(栈内存不够用)5.栈溢出默认是1000,但是当递归到998就已经报错了。 栈溢出错误：1栈溢出错误：RecursionError: maximum recursion depth exceeded in comparison 解决栈溢出的办法：123#修改递归深度的值import syssys.setrecursionlimit(2000) 关于栈溢出例子：12345678import syssys.setrecursionlimit(2000) #设置最大递归深度是2000def sum_digui_func(n): if n &lt;= 0: return 0 return n + sum_digui_func(n-1)#当我们运行到1997是，还是可以运行的。到1998就报错，所以可以认为比设置最大递归深度-3就是可以运行的。print(sum_digui_func(1997)) 说到递归就要说下逆向思维，在大部分情况下，人们所想的是都是片面，也就是有局限性。逆向思维就是突破这个局限性，从另一方面去想怎么解决这个事情。 逆向思维小故事 1234关于司马光砸缸： 讲述了司马光砸坏水缸，救出同伴的古诗。 在大部分情况下的人，当时所想的是如何让人脱离水，从而救出人。 我们通过逆向思维，想到也可以使水脱离人，从而脱救，于是把水缸砸坏，使水流光从而进行救助。 递归求和 1234567def sum_func(n): #设定出口，退出条件 if n &lt;= 0: return 0 #调用自身，每次和自身-1相加 return n + sum_func(n-1)print(sum_func(5)) 阶乘 1234567def ride_func(n): #设定出口，退出条件 if n &lt;= 1: return 1 #调用自身，每次和自身-1相乘 return n + ride_func(n-1)print(ride_func(5))","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'设计模式之工厂模式'","slug":"设计模式之工厂模式","date":"2020-06-02T08:34:10.000Z","updated":"2020-06-02T11:18:57.349Z","comments":true,"path":"2020/06/02/设计模式之工厂模式/","link":"","permalink":"http://www.okwzh.cn/2020/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。","text":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。 简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。简单工厂实例化的类具有相同的接口或者基类，在子类比较固定并不需要扩展时，可以使用简单工厂。如数据库生产工厂就是简单工厂的一个应用采用简单工厂的优点是可以使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性；缺点是可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂，不符合OCP（开闭原则）的原则。简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。 与django结合实现工厂模式 12345678910111213141516171819202122232425262728293031323334class WeiBo: def __repr__(self): return '使用微博进行第三方登录'class DingDing: def __repr__(self): return '使用钉钉进行第三方登录'class Gitee: def __repr__(self): return '使用马云进行第三方登录'#实例化类weibo = WeiBo()dingding = DingDing()gitee = Gitee()#简单工厂模式class Factory: #这里使用静态方法 @staticmethod def Login(name): if name == 'weibo': return WeiBo() elif name == 'dingding': return DingDing() elif name == 'gitee': return Gitee()factory = Factory.Login(\"weibo\")#当name==weibo，输出使用微博进行第三方登录#当name==dingding，输出使用使用钉钉进行第三方登录#当name==gitee，输出使用马云进行第三方登录print(factory)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'schedule的定时任务'","slug":"celery的定时任务","date":"2020-06-01T06:44:33.000Z","updated":"2020-06-02T11:18:18.841Z","comments":true,"path":"2020/06/01/celery的定时任务/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/celery%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"使用定时任务定时执行","text":"使用定时任务定时执行 启动定时任务命令 12在和manage.py文件同级目录下： celery -A mydjango beat -l info 注意： 1234启动定时任务需要启动三个服务1.django后台服务：python manage.py runserver2.selery后台服务：celery worker -A mydjango -l info -P eventlet3.定时任务服务：celery -A mydjango beat -l info 启动定时任务出现错误 12ERROR: Pidfile (celerybeat.pid) already exists.Seems we're already running? (pid: 29396) 这个错误就是说启动服务的文件夹里有启动文件celerybeat.pid了，把他删掉就可以了，记得再次重启 在settings中配置12345678910111213#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称,解析字符串寻找 'schedule':timedelta(seconds=7200) #定时时长 &#125;&#125; 结合Django使用一个小案例：每1分钟提交一次log文件12345678910111213141516171819202122232425262728在settings配置#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称 'schedule':timedelta(seconds=60) #定时时长，,1分钟 &#125;&#125;创建一个task.py文件from celery.task import task#自定义异步任务@taskdef async_test(): print('异步任务') #文件名 filename = 'celeray.log' #追加形式写入 with open(filename,'a') as f: #写入文件时间 f.write(str(datetime.datetime.now())+'\\n') return '123123'","categories":[],"tags":[{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"}]},{"title":"'关于使用selery出现错误的问题'","slug":"关于使用selery出现错误的问题","date":"2020-06-01T03:38:28.000Z","updated":"2020-06-02T09:10:00.582Z","comments":true,"path":"2020/06/01/关于使用selery出现错误的问题/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8selery%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"启动celery命令 1celery worker -A celery_task -l info -P eventlet","text":"启动celery命令 1celery worker -A celery_task -l info -P eventlet 在django中使用restful风格做开发时，发现都不能发送在使用post方法的时候，因为我的celery后台一直是启动的，所以不运行task中封装的函数，然后一直在找解决办法，于是我重启celery后台，会出现一个错误 该错误描述： 1TypeError: wrap_socket() got an unexpected keyword argument '_context' 于是找了解决办法，换个启动命令request包的request.post发送后，传不回数据 所以，在改变服务器启动方法不要用eventlet，加个参数 1celery worker -A mydjango -l info -P=solo 来源: Apical转载于: https://www.sirxs.cn/2020/06/01/Note/celery_error/","categories":[],"tags":[]},{"title":"'celery异步的使用'","slug":"celery异步的使用","date":"2020-06-01T01:23:44.000Z","updated":"2020-06-02T09:10:16.863Z","comments":true,"path":"2020/06/01/celery异步的使用/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/celery%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2","text":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2 django配置celery在settings中配置123456#代理url，异步任务代理CELERY_BROKER_URL = 'redis://localhost:6379/'#保存结果CELERY_RESULT_BACKEND = 'redis://localhost:6379/'#保存类型格式，使用jsonCELERY_RESULT_SERIALIZER = 'json' 在和settings同一级目录下，创建celery.py文件，进行配置文件，用来启动服务123456789101112131415# -*- coding: utf-8 -*-from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery# 设置环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mydjango.settings')# 注册Celery的APPapp = Celery('mydjango')# 绑定配置文件,声明命名空间,可以在电脑任何位置启动app.config_from_object('django.conf:settings', namespace='CELERY')# 自动发现各个app下的tasks.py文件app.autodiscover_tasks() 在和settings同一级目录下的init.py文件下，当启动服务，加载init.py文件配置12345678910from __future__ import absolute_import, unicode_literalsfrom .celery import app as celery_app#导包import pymysql#初始化pymysql.install_as_MySQLdb()#加载celery应用__all__ = ['celery_app'] 在myapp文件夹下，创建一个tasks.py文件，自定义任务123456789from celery.task import task#自定义异步任务#实用装饰器声明是异步任务@taskdef async_test(): print('异步任务') return '123123' 触发异步任务队列1234567#调用tasks异步from myapp import tasks#触发异步任务视图def celery_test(request): #使用delay()异步任务调用 res = tasks.async_test.delay() return JsonResponse(&#123;'task_id':res.task_id&#125;) 配置url12345from myapp.views import celery_testurlpatterns = [ #定义超链接路由 path('celery_test/',celery_test),] 启动celery服务1231.先启动django服务：python manage.py runserver2.在manage.py文件的同级目录下，启动celery服务3.以协程方式启动服务命令：celery worker -A mydjango -l info -P eventlet 实例:做邮件发送使用celery123456789101112131415161718192021222324252627282930313233343536373839404142#task中：from celery.task import taskfrom mydjango.settings import MY_MAIL,MY_PASSfrom email.mime.text import MIMETextfrom email.utils import formataddrimport smtplib@taskdef mail(subject,content,mailaddr): #声明邮件对象 msg = MIMEText(content,'plain','utf-8') #设置发送方对象 msg['From'] = formataddr(['在线教育平台',MY_MAIL]) #设置收件方对象 msg['To'] = formataddr(['尊敬的客户',mailaddr]) #设置标题 msg['Subject'] = subject #设置smtp服务器 server = smtplib.SMTP_SSL('smtp.qq.com',465) #登录邮箱 server.login(MY_MAIL,MY_PASS) #发送邮件 server.sendmail(MY_MAIL,[mailaddr],msg.as_string()) #关闭smtp连接，节约系统资源 server.quit()#退出#在视图中class Register(APIView): def post(self,request): email = request.data.get('email') #获取前端用户邮件 subject = '亲爱的用户您好：,欢迎注册在线教育平台' #邮件标题 yanzhengma = random.randint(1000,9999) print(yanzhengma) #数字验证码 r.set('email',yanzhengma,120) #存到redis print(123,r.get('email')) content = '欢迎注册在线教育平台，您的验证码是%s，请在2分钟内输入，失效请重新获取' % yanzhengma print(content) #邮件内容 mailaddr = email #给发送邮件 #参数需要存放到delay(里) send_email = tasks.mail.delay(subject, content, mailaddr) #异步发送邮件调用邮件 #使用celery需要使用JsonResponse返回 return JsonResponse(&#123;'code':200,'yzm':yanzhengma,'send_email':send_email.task_id&#125;)","categories":[],"tags":[{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"}]},{"title":"git","slug":"git","date":"2020-05-31T05:10:10.000Z","updated":"2020-06-04T05:09:00.090Z","comments":true,"path":"2020/05/31/git/","link":"","permalink":"http://www.okwzh.cn/2020/05/31/git/","excerpt":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。","text":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。 Git的下载与安装1git的下载与安装:https:&#x2F;&#x2F;blog.csdn.net&#x2F;Dan_Xiao_Hui&#x2F;article&#x2F;details&#x2F;105637182 在Gitee上创建仓库12345678910111213141516171819202122232425在Gitee上创建仓库： 1.点击+号，新建仓库，如图1, 2.编辑仓库名，仓库路径，仓库描述，公开 3.点击创建创建git仓库： 1.创建一个文件夹cangku:mkdir cangku 2.进入文件夹：cd cangku 3.初始化git：git init 4.将要上传的文件添加到暂存区：git add -A 5.将暂存区文件提交到仓库：git commit -m &#39;描述&#39; 6.因为是第一次上传，所以需要确定好gitee的git仓库： git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;wang_zeng_hui&#x2F;cangku.git #####只有第一次上传，需要确定Git仓库位置，以后不需要 7.推送到云端：git push -u origin master需要用户名或密码：(只需要写入一次)(图4) git config --global user.name &quot;你登录gitee的名字&quot; git config --global user.email &quot;你登录的email&quot;删除仓库： 1.进入管理(如图5) 2.点击删除仓库(如图6) 3.根据要求输入内容(如图7) 4.登录账号,进行验证(如图8) 图1 图2 图3 图4 删除仓库图5 图6 图7 图8 Git的命令1234567891011121314Git的常用命令： 1.将线上网址克隆到本地：git clone git网址 2.将工作区的修改添加到暂存区：git add -A 3.将暂存区的文件提交到仓库：git commit -m &#39;描述&#39; 4.将仓库推送到云端：git push origin master其他命令： 清掉配置：git config --system --unset credential.helper 保存密码：git config --global credential.helper store 查看版本日志：git log 简单日志：git log --pretty&#x3D;oneline 回退操作：git reset --hard &#39;版本号&#x2F;日志&#39; 回退之后返回之前操作日志：git reflog git reset --hard &#39;版本号&#x2F;日志&#39; Git的分支命令123456789101112131415在我们每次提交之后都会有记录，Git把它们穿成时间线，形成类似于时间轴的东西。这个时间轴就是一个分支，我们称之为master分支。分支相关命令： 查看分支：git branch 查看所有分支：git branch -a 查看远端分支：git branch -r 创建并切换分支：git checkout -b 分支名 建立本地与线上分支关联：git push --set-upstream origin 分支名(可以不切换分支就能提交) 创建分支：git branch 分支名 切换分支：git checkout 分支名 合并分支：git merge 被合并的分支名（需要先切换到master分支） 删除分支：git branch -d 分支名 删除远程分支：git push origin --delete 分支名 注意：当我们进行删除分支的时候，注意要先退出要删除的分支，不然会报错。 Git的合并1234561.创建dev分支：git checkout -b dev2.将本地分支提交线上：git push --set-upstream origin dev3.切换master分支：git checkout master4.合并分支：git merge dev(直接push提交，不需要推送)5.合并之后推送到线上：git push origin master","categories":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/tags/git/"}]},{"title":"'序列化类的使用'","slug":"day13-序列化类的使用","date":"2020-05-10T02:13:08.000Z","updated":"2020-06-06T07:31:57.032Z","comments":true,"path":"2020/05/10/day13-序列化类的使用/","link":"","permalink":"http://www.okwzh.cn/2020/05/10/day13-%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"rest_framework的下载1pip install djangorestframework","text":"rest_framework的下载1pip install djangorestframework 在settings中注册rest_framework123456789101112INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'corsheaders', #后端跨域 'rest_framework', #rest_framework框架 'myapp', 'dwebsocket'] 在django的app中创建一个serializers.py文件12345678910111213#导包from rest_framework import serializers#导入需要序列化的表from myapp.models import *#建立序列化类class CarouselSer(serializers.ModelSerializer): #针对表进行序列化 class Meta: model = Carousel #表名 fields = '__all__' #所有字段 在views视图中123456789from myapp.myser import * #导入序列器class GetCarousel(APIView): def get(self,request): #读库 carousels = Carousel.objects.all() #序列化操作 carousels_ser = CarouselSer(carousels,many=True) return Response(carousels_ser.data) 使用序列化的增删改查操作12345678910111213141516171819202122232425262728293031323334353637383940#url： path('getcarousel/',GetCarousel.as_view()),class GetCarousel(APIView): #查询操作 def get(self,request): #读库 carousels = Carousel.objects.all() #序列化操作 carousels_ser = CarouselSer(carousels,many=True) return Response(&#123;'data':carousels_ser.data&#125;) #添加操作 def post(self,request): name = request.data.get('name',None) src = request.data.get('link',None) img = request.data.get('imgs',None) ser = Carousel.objects.filter(name=name).first() if ser: return Response(&#123;'msg':'幻灯片已存在'&#125;) carousel = Carousel(name=name,src=src,img=img) carousel.save() #保存入库 return Response(&#123;'code': 200, 'msg': '添加成功'&#125;) #删除操作 def delete(self,request): id = request.GET.get('id',None) Carousel.objects.filter(id=id).delete() return Response(&#123;'code': 200, 'msg': '删除成功'&#125;) #修改操作 def put(self,request): id = request.data.get('id',None) name = request.data.get('name',None) src = request.data.get('link',None) img = request.data.get('imgs',None) car = Carousel.objects.filter(id=id).first() car.name = name car.src = src car.img = img car.save() return Response(&#123;'code':200, 'msg': '修改成功'&#125;) 注意12345rest_framework自带增删改查四种方法查询：get：Carousel.objects.all() ---&gt;method:'GET'增加：post：carousel.save() ---&gt;method:'POST(data)',request.data.get()删除：delete：Carousel.objects.filter(id=id).delete() ---&gt;method:'DELETE(params)',request.GET.get()修改：put：carousel.save() ---&gt;method:'PUT(data)',request.data.get() vue代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;template&gt; &lt;div&gt; &lt;center&gt; &lt;table border=\"1\" style=\"text-align: center;\"&gt; &lt;tr&gt; &lt;td&gt; 名称 &lt;/td&gt; &lt;td&gt; 链接 &lt;/td&gt; &lt;td&gt; 图片 &lt;/td&gt; &lt;td&gt; 添加 &lt;/td&gt; &lt;td&gt; 修改 &lt;/td&gt; &lt;td&gt; 删除 &lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in lunbo_list\" :key=\"index\"&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &#123;&#123;item.name&#125;&#125; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;a :href=\"item.src\" target=\"_black\"&gt;&#123;&#123;item.src&#125;&#125;&lt;/a&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;img :src=\"item.img\" alt=\"\"&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"green\" @click=\"put_lunbo(item.id)\"&gt;修改&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"red\" @click=\"del_lunbo(item.id)\"&gt;删除&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; name：&lt;input type=\"text\" v-model=\"name\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; img：&lt;input type=\"text\" v-model=\"imgs\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; src：&lt;input type=\"text\" v-model=\"link\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;br&gt; &lt;tr&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"blue\" @click=\"add_lunbo\"&gt;添加&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/tr&gt; &lt;/table&gt; &lt;/table&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; name：&lt;input type=\"text\" v-model=\"name\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; img：&lt;input type=\"text\" v-model=\"imgs\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; src：&lt;input type=\"text\" v-model=\"link\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;br&gt; &lt;tr&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"blue\" @click=\"put_lunbo1\"&gt;修改&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/tr&gt; &lt;/table&gt; &lt;/center&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; lunbo_list:[], name:\"\", link:\"\", imgs:\"\", &#125; &#125;, mounted() &#123; this.lunbo(); &#125;, methods: &#123; lunbo()&#123; this.axios(&#123; url:'http://localhost:8000/getcarousel/', method:'GET', &#125;).then(resp=&gt;&#123; console.log(resp) this.lunbo_list = resp.data.data &#125;) &#125;, //增加 add_lunbo()&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'POST', data:&#123; name:this.name, link:this.link, imgs:this.imgs, &#125; &#125;).then(resp=&gt;&#123; console.log(resp) this.$router.go(0) &#125;) &#125;, //删除 del_lunbo(id)&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'DELETE', params:&#123; id:id &#125; &#125;).then(resp=&gt;&#123; console.log(resp) alert(resp.data.msg) this.$router.go(0) &#125;) &#125;, //修改跳转 put_lunbo(id)&#123; //网页跳转传递id this.$router.push(&#123;'path':'/my_lunbo',query:&#123;'aid':id&#125;&#125;) &#125;, //修改 put_lunbo1()&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'PUT',//指定修改方法 data:&#123; id:this.$route.query.aid, name:this.name, link:this.link, imgs:this.imgs, &#125; &#125;).then(resp=&gt;&#123; console.log(resp) alert(resp.data.msg) this.$router.go(0) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;img&#123; width: 100px; height: 100px;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'Django中间件'","slug":"day13-django中间件","date":"2020-05-07T18:46:11.000Z","updated":"2020-06-06T07:42:12.675Z","comments":true,"path":"2020/05/08/day13-django中间件/","link":"","permalink":"http://www.okwzh.cn/2020/05/08/day13-django%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"django的生命周期流程图中间件位于web服务端与url路由层之间 中间件的响应流程：当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。","text":"django的生命周期流程图中间件位于web服务端与url路由层之间 中间件的响应流程：当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。 中间件的五个方法1234567891011121314151617181920212223# 导包from django.utils.deprecation import MiddlewareMixin #中间件class My_MiddlewareMixin(MiddlewareMixin): # 请求之前 def process_request(self, request): pass # 视图渲染之前 def process_view(self, request, view_func, view_args, view_kwargs): pass # 该方法对视图函数返回值有要求，必须是一个含有render方法类的对象，才会执行此方法 def process_template_response(self, request, response): pass def process_exception(self, request, exception): pass # 返回之前 def process_response(self, request, response): # 注意：response需要使用return返回，不然报错 return response process_view的参数12345678# 该方法有四个参数# request是HttpRequest对象。# view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）# view_args是将传递给视图的位置参数的列表（无名分组分过来的值）.# view_kwargs是将传递给视图的关键字参数的字典（有名分组分过来的值）。 view_args和view_kwargs都不包含第一个视图参数（request）。# Django会在调用视图函数之前调用process_view方法。def process_view(self, request, view_func, view_args, view_kwargs): pass process_response错误：123456 if response.get('X-Frame-Options') is not None:AttributeError: 'NoneType' object has no attribute 'get'# 原因：就是没有返回response# 解决def process_response(self, request, response): return response 定义中间件之后在settings中注册中间件12345678910111213MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', #这里是新增的中间件 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', #加载自定义中间件 文件夹名.文件名.类名 # 'myapp.views.MyMiddleware', 'myapp.md_user.My_MiddlewareMixin',] 使用django原生Httpresponse返回Json格式123456789def process_request(self, request): # 第一种： # content_type=\"application/json\"声明json类型 # indent=4四个空格，美观 # ensure_ascii=False不使用ascii编码，输出中文 return Httpresponse(json.dumps(&#123;'message':'您的秘钥无权限'&#125;,indent=4,ensure_ascii=False),content_type=\"application/json\") # 第二种： # json_dumps_params=dict return JsonResponse(&#123;'message':'您的秘钥无权限'&#125;,safe=False,json_dumps_params=(&#123;'ensure_ascii':False,'indent':4&#125;)) 因为每次请求都要走中间件，所以针对路由判断是否走中间件1234def process_request(self, request): # 获取路由 if request.path_info.startswith('/userinfo/'): return Httpresponse(json.dumps(&#123;'message':'您的秘钥无权限'&#125;,indent=4,ensure_ascii=False),content_type=\"application/json\")","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'第三方登录-钉钉登录'","slug":"day08-第三方登录-钉钉登录","date":"2020-04-28T05:10:38.000Z","updated":"2020-06-06T07:57:39.608Z","comments":true,"path":"2020/04/28/day08-第三方登录-钉钉登录/","link":"","permalink":"http://www.okwzh.cn/2020/04/28/day08-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-%E9%92%89%E9%92%89%E7%99%BB%E5%BD%95/","excerpt":"钉钉企业注册：点击跳转 官方文档：点击跳转 悦哥钉钉登录博客：点击查看","text":"钉钉企业注册：点击跳转 官方文档：点击跳转 悦哥钉钉登录博客：点击查看 钉钉登录1.注册钉钉企业 2.登录企业后台管理 3.选择应用开发 4.移动接入应用-&gt;登录 5.创建扫码登录应用授权 6.获取创建以后企业应用的appid,appsecret,回调域名 代码示例12345678910urls：path('ding_url/',ding_login),#登录顶顶def ding_login(request): #钉钉应用的appid appid = 'dingoab7edavvvtdcwqcra' # 钉钉应用的回调地址 redirect_uri = 'http://127.0.0.1:8000/callback/' #重定向到 return redirect('https://oapi.dingtalk.com/connect/qrconnect?appid=' +appid+'&amp;response_type=code&amp;scope=snsapi_login&amp;state=STATE&amp;redirect_uri='+redirect_uri) 7.钉钉会将code返回到回调网址中因为钉钉只有java和php的sdk,所以使用hmac加密自己写sdk 123456789101112131415161718192021222324252627282930313233343536373839urls：path('callback/',ding_back),#构造钉钉对调方法。def ding_back(request): #获取code code = request.GET.get('code',None) print('code是：%s'%code) #构造时间戳 t = time.time() timestamp = str(int(round(t*1000))) print('时间：',timestamp) #URL签名参数说明 #钉钉的appSecret appSecret = '8F3q2UmU-2ljILNJAtodsnFaLllpMEioNWI5GRtnoz5OyubMYbiTxlVC3yrPmHiE' #构造签名 signature = base64.b64encode(hmac.new(appSecret.encode('utf-8'),timestamp.encode('utf-8'),digestmod=sha256).digest()) #请求接口，换取用户名 payload = &#123;'tmp_auth_code':code&#125; headers = &#123;'Content-Type':'application/json'&#125; res = requests.post('https://oapi.dingtalk.com/sns/getuserinfo_bycode?' 'accessKey=dingoab7edavvvtdcwqcra&amp;timestamp='+timestamp+ '&amp;signature='+urllib.parse.quote(signature.decode('utf-8')),headers=headers,data=json.dumps(payload)) res_dict = json.loads(res.text) print(res_dict) username = str(res_dict['user_info']['nick']) user = User.objects.filter(username=username).first() if user: #数据库有该用户名，直接登录 user.username = username print('已经登陆过，用户名',username) else: #没有登录,注册 user = User(username=username) user.save() print('首次注册，用户名',username) return redirect('http://localhost:8080/?username='+username) # return HttpResponse(res.text)","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"第三方登录-微博登录","slug":"day08-第三方登录-微博登录","date":"2020-04-28T03:24:55.000Z","updated":"2020-06-06T07:49:34.286Z","comments":true,"path":"2020/04/28/day08-第三方登录-微博登录/","link":"","permalink":"http://www.okwzh.cn/2020/04/28/day08-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-%E5%BE%AE%E5%8D%9A%E7%99%BB%E5%BD%95/","excerpt":"微博登录思维导图","text":"微博登录思维导图 在微博创建应用1.第一步2.第二步3.第三步4.第四步5.第五步6.第六步 代码示例vue代码 123456789101112131415161718192021222324252627282930&lt;template&gt;&lt;div&gt;&lt;img :src=\"wb_src\" alt=\"点击跳转微博第三方登录\" @click=\"sina\" class=\"imgcode\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; //微博登录url //图片路径 wb_src:'http://127.0.0.1:8000/static/sina.png', &#125; &#125;, methods:&#123; //微博第三方登录 sina()&#123; //拼接url //App Key let client_id = 2731357014; //授权回调页 let redirect_uri = 'http://127.0.0.1:8000/md_admin/weibo'; // //请求url let url = 'https://api.weibo.com/oauth2/authorize?client_id='+client_id+'&amp;redirect_uri='+redirect_uri; // //跳转微博登录页,//返回code，然后后端去接收 window.location.href = url &#125; &#125; &#125; django代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950urls路径配置：path('md_admin/weibo/',wb_back),#新浪微博回调方法def wb_back(request): #接受参数 code = request.GET.get('code',None) print('code是%s'%code) #定义token的获取地址 url = 'https://api.weibo.com/oauth2/access_token' #定义参数 data = &#123; 'client_id':'2731357014',#App Key 'client_secret':'3eb11995fdd72c3b33b3971caac21ffe',#App Secret 'grant_type':'authorization_code',#类型 'code':code,#获取到的code 'redirect_uri':'http://127.0.0.1:8000/md_admin/weibo' &#125; re = requests.post(url=url,data=data) print('re的json是：',re.json()) #换取新浪微博用户昵称 weibo_url = 'https://api.weibo.com/2/users/show.json' params = &#123; 'access_token':re.json()['access_token'], 'uid':re.json()['uid'] &#125; res = requests.get(url=weibo_url,params=params) print('res的json是：',res.json()) print(res.json()) #定义新浪id和用户id sina_id = '' user_id = '' #判断是否使用新浪微博登陆过 user = User.objects.filter(username=str(res.json()['name'])).first() if user: #代表该账号曾经登陆过 sina_id = user.username user_id = user.id else: #首次登录,入库 user = User(username=str(res.json()['name']),password=\"\") user.save() user = User.objects.filter(username=str(res.json()['name'])).first() sina_id = user.username user_id = user.id print('用户是：',sina_id,user_id) #重定向到首页 return redirect('http://127.0.0.1:8080?sina_id='+str(sina_id)+'&amp;user_id='+str(user_id)) # return HttpResponse('回调成功') 关于错误123今日写微博登录犯了一个很典型的错误: 就是单词打错：所有的client都拼写成了clinet 因为是在访问url，所以报了一个'请求不合法错误'","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"项目目录","slug":"day02项目目录","date":"2020-04-20T23:55:29.000Z","updated":"2020-06-02T09:05:19.935Z","comments":true,"path":"2020/04/21/day02项目目录/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/","excerpt":"vue有关项目目录","text":"vue有关项目目录 vue的项目目录1234567891011121314151617181920212223build:打包文件config:配置文件 dev.env.js:开发环境变量 index.js:生产环境变量 prod.env.js:灰度环境dist:打包之后存放的文件node_modules:安装的依赖，配置文件,基于package.json下载(该文件不能提交到仓库,需要加入.gitignore).gitignore:存放不需要上传仓库的文件package.json:读取存放依赖，配置等信息 heyui:网页样式 js-mds:加密 style-loader:样式 vue:vue本体 vue-drag-verify:验证码 vue-router:路由components:组件文件夹router&#x2F;index.js:路由 path：路径url name：命名空间 components:导包组件 mode：&#39;history&#39; 取消hash风格的#App.vue：渲染组件main.js：入口文件，vue的组件，实例等都存在这里 hugo的项目目录123456789101112131415161718archetypes:文本配置文件content:生成的md文档data:数据文件夹layouts:布局public:打包文件resources:资源static:静态文件thems:主题config.homl:网站配置文件 baseURL:线上&#x2F;线下url languageCode:语言 title:标题 theme:主题 params：简介和描述 description:简介 themColor:博客主题颜色修改主题颜色：在themes--&gt;hyde--&gt;static--&gt;css--&gt;hyde.css中改颜色(可以自定义主题和颜色)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]},{"title":"Vue启动和命令","slug":"day02vue启动和命令","date":"2020-04-20T23:03:21.000Z","updated":"2020-06-02T09:11:22.987Z","comments":true,"path":"2020/04/21/day02vue启动和命令/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02vue%E5%90%AF%E5%8A%A8%E5%92%8C%E5%91%BD%E4%BB%A4/","excerpt":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0)","text":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0) 三大框架(三大框架都是基于node)1234567891011React： 1 自组件重复渲染问题需要手动优化 2 可以使用redux进行状态管理，函数式，不可变，模式化，时间旅行 3 可使用JSX，完全的javascript能力 4更繁荣的社区生态Vue： 1 可使用JSX，但推荐使用模版语言而不是JSX 2 学习曲线平缓Angular： 1 完善的MV框架，包含模版，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能 2 typescript 3 脏检查，对脏数据的检查，比较UI和后台的数据是否一致 安装依赖(npm)12345678910111213npm： 1.npm官网：https:&#x2F;&#x2F;www.npmjs.com&#x2F; 2.下载安装npm 3.给npm配置环境变量检查npm： 命令：npm -v (6.14.4)关于npm命令： 1.npm默认源是github，因为是外网，所以我们要改源（淘宝源）。命令： npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org 2.查看npm配置：npm config list 3.当npm版本过低，更新版本：npm install -g npm vue1234567891011121314151617181920vue的中文文档：https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html关于vue命令： 1.清空本地缓存：npm cache clean --force 1.在vue中安装依赖&#x2F;配置文件：npm install 2.启动vue：npm run dev 退出：ctrl+cvue依赖： npm install axios --save npm install style-loader —-save npm install heyui --save npm install js-md5 --save关于vue服务启动失败： 1.关掉命令行，退到上一级目录，手动删除node_modules,然后npm install 2.下载rimarf命令：npm install rimraf -g 删除node_modules命令：rimraf node_modules (图2) #使用前提，npm需要是新版本 #优先使用第二个理由：第一个手动删除需要花费大量时间，删除进度缓慢","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]},{"title":"环境变量的配置","slug":"day02环境变量","date":"2020-04-20T18:58:38.000Z","updated":"2020-06-02T09:14:40.885Z","comments":true,"path":"2020/04/21/day02环境变量/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"环境变量的配置1.找到此电脑","text":"环境变量的配置1.找到此电脑 2.点击右键–&gt;属性 3.点击高级系统设置 4.点击环境变量 5.选择用户变量或者系统变量，点击path，点击编辑 6.点击新建，然后输入需要配置环境变量的路径，一般情况下在bin目录（或者在cmd下） 7.编辑好路径之后，点击确定，再点击确定。然后退出环境变量，确保更改成功。8.ok","categories":[],"tags":[]}],"categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"},{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/categories/git/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"hexo博客","slug":"hexo博客","permalink":"http://www.okwzh.cn/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"},{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/tags/git/"},{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]}