{"meta":{"title":"WZH的博客","subtitle":"","description":"","author":"王增辉","url":"https://wzh3683.github.io/hexo_blog","root":"/hexo_blog/"},"pages":[{"title":"所有分类","date":"2020-06-05T11:00:44.079Z","updated":"2020-06-05T11:00:44.079Z","comments":false,"path":"categories/index.html","permalink":"https://wzh3683.github.io/hexo_blog/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-28T12:12:33.000Z","updated":"2020-06-17T01:57:47.050Z","comments":false,"path":"about/index.html","permalink":"https://wzh3683.github.io/hexo_blog/about/index.html","excerpt":"","text":"————————————————————————————————————————————————————————————————————————————————————————————————— *基本信息王增辉 1998年4月 北京 Python全栈开发工程师 3年工作经验 手机：13383913683 邮箱：okwzh3683@gmail.com 个人网站：https://www.okwzh.cn—————————————————————————————————————————————————————————————————————————————————————————————————*个人简介三年Python全栈开发经验，有过海外工作经验，掌握Django框架，作为主力工程师参与设计于开发过多个项目，负责系统核心模块的开发，测试与自动化部署，由高并发WEB应用框架经验。掌握爬虫技术，熟练使用Scrapy，熟悉前端业务规范，掌握vue.js开发，掌握websocket，掌握MySQL,redis，MongoDB数据库与LINux系统的常见机制与原理。由优秀的学习能力与团队沟通能力，经常与团队进行技术分享，能与团队共同成长。—————————————————————————————————————————————————————————————————————————————————————————————————*教育经历2012.08 - 2016.06 北京电子科技大学通信工程学院 统招一本—————————————————————————————————————————————————————————————————————————————————————————————————*技能列表● 后端框架：Django，Flask，Scrapy ● 前端：Vue.js,axios,jquery,node.js ● 前端框架：Vue.js，Node.js ● 数据库：MySQL , redis , MongoDB ● 工具：Git,Docker,Postman ● 编译器：PyCharm,Visual Studio Code,Sublime Text—————————————————————————————————————————————————————————————————————————————————————————————————*工作经历● 2017年9月 - 2019年5月 北京谐云科技有限公司—初级python开发工程师 ● 2019年7月 - 至今 北京微点网络科技有限公司—高级全栈开发工程师—————————————————————————————————————————————————————————————————————————————————————————————————*近期参与项目主导北京谐云科技跨境移动聚合支付平台开发● 搭建基于Docker挂载Nginx-rtmp的直播服务器 ● 使用FFmpeg利用客户端设备进行推流，对视频进行头图提取，精华片段转换动图，视频埋点，视频信息分析等操作 ● 开发，测试点播，直播，播单等7个模块 ● 采用FastDfs分布式文件系统作为海量视频存储方案，利用视频指纹规避重复文件问题,节约了大约20%的硬盘空间 ● 在网页端使用vue.js作为载体利用video.js作为直播流播放器，优化延迟达到500ms左右 ● 利用Nginx反向代理后台uwsgi+Django的点播接口，并且针对性使用Nginx负载均衡策略 ● 使用Bootstrap作为播放页响应式设计解决方案，一套代码自适应大小屏应用，降低了50%左右的移动端开发成本 ● 利用协同过滤算法针对用户和视频两个维度分别画像，定制视频精准推荐系统 主导北京谐云科技跨境移动聚合支付平台开发● 基于Django实现Restful风格的在线聚合支付接口，聚合封装了支付宝，微信，京东等三方支付平台，paypal跨境支付。 ● 使用Mysql存储数据，配置主从热备，使用Celery实现异步邮箱和短信推送 ● 利用Websocket实现后端消息主动推送，改造前端传统轮询技术框架，减少了30%的网络请求数，节约了大约一半的可用带宽 ● 使用Redis作为缓存介质，利用其分布式锁和队列的特性开发并测试抢单秒杀功能 ● 开发，测试登录/注册，订单，支付/退款等7个模块"},{"title":"秃顶程序员plus","date":"2020-06-17T14:29:47.701Z","updated":"2020-06-17T14:29:47.701Z","comments":false,"path":"friends/index.html","permalink":"https://wzh3683.github.io/hexo_blog/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-20T10:35:35.282Z","updated":"2020-06-20T10:35:35.282Z","comments":true,"path":"tags/index.html","permalink":"https://wzh3683.github.io/hexo_blog/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-05T11:35:31.222Z","updated":"2020-06-05T11:35:31.222Z","comments":true,"path":"comments/index.html","permalink":"https://wzh3683.github.io/hexo_blog/comments/index.html","excerpt":"","text":""}],"posts":[{"title":"'在线客服系统-基于flask+vue+socket.io实现在线客服系统'","slug":"在线客服系统-基于flask-vue集成项目","date":"2020-06-28T08:52:56.000Z","updated":"2020-07-06T04:27:17.083Z","comments":true,"path":"2020/06/28/在线客服系统-基于flask-vue集成项目/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/28/%E5%9C%A8%E7%BA%BF%E5%AE%A2%E6%9C%8D%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E4%BA%8Eflask-vue%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE/","excerpt":"socket.io介绍Socket.IO 就是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node（现在也支持python,go lang等语言）。其屏蔽了所有底层细节，让顶层调用非常简单，另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。","text":"socket.io介绍Socket.IO 就是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node（现在也支持python,go lang等语言）。其屏蔽了所有底层细节，让顶层调用非常简单，另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信，这一点就比websocket要智能不少。 后台服务搭建结合python和flask需要的模块 1234pip install flaskpip install flask-corspip install flask-socketiopip install Flask-SQLAlchemy 本次模块对应版本号 1234Flask 1.1.1Flask-Cors 3.0.8Flask-SocketIO 4.3.0Flask-SQLAlchemy 2.4.1 flask的启动文件manage.py1234567891011121314151617181920212223242526272829303132from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport pymysqlfrom flask import request,jsonifyfrom flask_cors import CORSfrom flask_socketio import SocketIO,send,emitimport urllib.parsepymysql.install_as_MySQLdb() app = Flask(__name__)CORS(app,cors_allowed_origins=\"*\")socketio = SocketIO(app,cors_allowed_origins='*') @socketio.on('message')def handle_message(message): message = urllib.parse.unquote(message) print(message) send(message,broadcast=True)@socketio.on('connect', namespace='/chat')def test_connect(): emit('my response', &#123;'data': 'Connected'&#125;)@socketio.on('disconnect', namespace='/chat')def test_disconnect(): print('Client disconnected') if __name__ == '__main__': socketio.run(app,debug=True,host=\"0.0.0.0\",port=5000) 这里简单说一下需要注意的地方，实例化socketio对象的时候，要加上cors_allowed_origins来设置跨域，前后端分离项目让人伤脑筋的地方就是浏览器同源策略问题，而跨域最好由server端来单独配置，这样的好处是当多个前端项目同时共用一套微服务接口时，就不用每个前端项目都配置一次跨域了。 我们写了三个基于socketio的视图方法，connect和disconnect顾名思义，当clinet发起连接或者断开时我们可以及时捕获到，而message方法就是前后端进行消息通信的重要方法。 发送消息的时候方法加了一个broadcast参数，这是socket.io极具特色的功能，类似广播的效果，可以同时给不同链接的client发送消息，即可以用于聊天，也可以用来做消息推送。 最后需要注意的一点是，client发送消息时，最好用urlencode编码一下，这样可以解决中文乱码问题，而在server端，可以用urllib.parse.unquote()来进行解码操作。 运行命令启动后端服务1python manage.py 服务正常启动在5000端口上，就说明后端没有问题了。 前端配置配置前端(client)，前端采用vue2.0框架来驱动，也需要安装socket.io模块这里一定要指定版本号来安装，版本是2.1.0，因为该依赖的最新版在vue2.0项目中编译时会报错 1npm install vue-socket.io@2.1.0 在main.js中引用 123import VueSocketio from 'vue-socket.io';Vue.use(VueSocketio,'http://127.0.0.1:5000'); 注意链接的url是后端服务的地址+端口，千万不要加其他url后缀或者命名空间 新建一个用户页面，user.vue来模拟用户链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;div v-for=\"item in log_list\"&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;input v-model=\"msg\" /&gt; &lt;button @click=\"send\"&gt;发送消息&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: \"\", log_list:[] &#125; &#125;, //注册组件标签 components:&#123; &#125;, sockets:&#123; connect: function()&#123; console.log('socket 连接成功') &#125;, message: function(val)&#123; console.log('返回:'+val); this.log_list.push(val); &#125;&#125;, mounted:function()&#123; &#125;, methods:&#123; send()&#123; this.$socket.emit('message',encodeURI(\"用户:\"+this.msg)); &#125;, &#125;&#125;&lt;/script&gt;d&lt;style&gt;&lt;/style&gt; 启动前端服务 1npm run dev 访问前端页面 http://localhost:8080/user 可以看到服务成功链接 新建一个后台客服组件页面，item.vue用来模拟用户和客服在不同电脑进行聊天的场景 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div&gt; &lt;div v-for=\"item in log_list\" &gt; &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;input v-model=\"msg\" /&gt; &lt;button @click=\"send\"&gt;发送消息&lt;/button&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt;export default &#123; data () &#123; return &#123; msg: \"\", log_list:[] &#125; &#125;, //注册组件标签 components:&#123; &#125;, sockets:&#123; connect: function()&#123; console.log('socket 连接成功') &#125;, message: function(val)&#123; console.log('返回:'+val); this.log_list.push(val); &#125;&#125;, mounted:function()&#123; &#125;, methods:&#123; send()&#123; this.$socket.emit('message',encodeURI(\"客服:\"+this.msg)); &#125;, &#125;&#125;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; 最后效果","categories":[{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/categories/flask/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/tags/flask/"},{"name":"websocket","slug":"websocket","permalink":"https://wzh3683.github.io/hexo_blog/tags/websocket/"}]},{"title":"'flask第二弹——cookie和session'","slug":"flask第二弹——cookie和session","date":"2020-06-26T09:56:48.000Z","updated":"2020-06-26T10:01:31.148Z","comments":true,"path":"2020/06/26/flask第二弹——cookie和session/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/26/flask%E7%AC%AC%E4%BA%8C%E5%BC%B9%E2%80%94%E2%80%94cookie%E5%92%8Csession/","excerpt":"","text":"上一章讲了flask的入门,这一章说一下flask中的cookie和session 设置cookie和获取cookie123456789101112131415161718192021222324252627282930313233#导包from flask import Flask,make_response,request#建立flask对象app = Flask(__name__)# 从配置文件来加载配置app.config.from_pyfile('config.ini')#使用flask路由器，指定网址和控制器,首页@app.route('/')def index(): return 'hello python'#使用make_response库设置cookie@app.route('/set_cookie')def set_cookie(): resp = make_response('存储cookie') #使用set_cookie来存储key-value形式的数据 resp.set_cookie('username','wzh') return resp#使用request库获取cookie@app.route('/get_cookie')def get_cookie(): resp = make_response('获取cookie') #获取cookie需要使用request库 resp = request.cookies.get('username') # resp = request.cookies['username'] return respif __name__ == '__main__': app.run()","categories":[{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/categories/flask/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/tags/flask/"}]},{"title":"'flask第一弹——flask安装及入门'","slug":"flask第一弹——flask安装及入门","date":"2020-06-26T02:36:10.000Z","updated":"2020-06-26T09:55:37.489Z","comments":true,"path":"2020/06/26/flask第一弹——flask安装及入门/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/26/flask%E7%AC%AC%E4%B8%80%E5%BC%B9%E2%80%94%E2%80%94flask%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/","excerpt":"Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。Flask使用 BSD 授权。 Flask是一个轻量级的可定制框架，使用Python语言编写，较其他同类型框架更为灵活、轻便、安全且容易上手。它可以很好地结合MVC模式进行开发，开发人员分工合作，小型团队在短时间内就可以完成功能丰富的中小型网站或Web服务的实现。另外，Flask还有很强的定制性，用户可以根据自己的需求来添加相应的功能，在保持核心功能简单的同时实现功能的丰富与扩展，其强大的插件库可以让用户实现个性化的网站定制，开发出功能强大的网站。","text":"Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。Flask使用 BSD 授权。 Flask是一个轻量级的可定制框架，使用Python语言编写，较其他同类型框架更为灵活、轻便、安全且容易上手。它可以很好地结合MVC模式进行开发，开发人员分工合作，小型团队在短时间内就可以完成功能丰富的中小型网站或Web服务的实现。另外，Flask还有很强的定制性，用户可以根据自己的需求来添加相应的功能，在保持核心功能简单的同时实现功能的丰富与扩展，其强大的插件库可以让用户实现个性化的网站定制，开发出功能强大的网站。 下载安装flask依赖1234pip install Flaskpip install Flask-Corspip install Flask-Migratepip install Flask-SQLAlchemy flask的入门使用1234567891011121314#导包from flask import Flask,redirect,url_for,jsonify#建立flask对象app = Flask(__name__)#使用flask路由器route，指定网址和控制器@app.route('/')def index(): return 'hello python'#使用程序入口,将flask应用启动，port参数用来调整端口，默认端口是5000if __name__ == '__main__': app.run(debug=True) #debug=True测试 flask的路由传参1234@app.route('/hello/&lt;id&gt;')def hello(id): print(id) return '123 世界 参数%s'%id flask的跳转flask有两种跳转方式，一种是根据网址跳转，一种是根据函数名跳转 12345#使用重定向模块跳转@app.route('/re')def re():#redirect根据网址进行跳转 return redirect('http://okwzh.cn') 1234567#使用url_for来实现简单的站内跳转，参数是指定路由函数名@app.route('/url')def url(): #redirect根据函数名跳转 return redirect(url_for('re')) #跳转加参数 #return redirect(url_for('hello',id=1)) flask返回json类型12345678910111213#返回json数据@app.route('/json')def re_json(): json_dict = &#123; 'id':10, 'title':'王增辉', 'content':'这是json类型' &#125; return jsonify(json_dict)#解决中文乱码问题，让中文正常显示#访问之后我们发现返回的是json类型存在编码问题,于是我们在配置上添加app.config['JSON_AS_ASCII'] = False flask的钩子方法及使用12345678910111213141516171819202122#第一次请求前@app.before_first_requestdef brfore_first_request(): print('这是第一次请求之前调用的方法')#每次请求前@app.before_requestdef before_request(): print('每次请求之前调用的方法')#每次请求之后@app.after_request#必须传响应参数，将响应内容返回def after_request(response): print('每次请求之后调用的方法') return response#在请求之后，调用服务器出现的错误信息@app.teardown_requestdef teardown_request(e): print('服务器出现的错误是%s'%str(e)) flask添加配置文件的三种方式1.从配置文件里加载配置创建一个config.ini的文件，里面存放配置信息app.config.from_pyfile(‘config.ini’) 2.从环境变量中加载配置app.config.from_envvar(‘app_config’) 3.从配置对象来加载配置 123456#建立一个配置类class Config: DEBUG = True JSON_AS_ASCII = Falseapp.config.from_object(Config) flask统一对状态码捕获异常12345678#flask统一对状态码捕获异常@app.errorhandler(405)def get_error(e): return '这个接口不能被get获取到，只能被post获取'@app.errorhandler(404)def get_error2(e): return '网页不存在'","categories":[{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/categories/flask/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/tags/flask/"}]},{"title":"'python高阶函数'","slug":"python高阶函数","date":"2020-06-22T01:25:12.000Z","updated":"2020-06-22T03:01:54.950Z","comments":true,"path":"2020/06/22/python高阶函数/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/22/python%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"什么是高阶函数？高阶函数：一个函数可以作为参数传给另外一个函数，或者一个函数的返回值为另外一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数。","text":"什么是高阶函数？高阶函数：一个函数可以作为参数传给另外一个函数，或者一个函数的返回值为另外一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数。 函数作为参数 1234567891011def func(): print('这是第一个函数')def func_two(func): func() print('这是第二个函数')func_two(func)#这是第一个函数#这是第二个函数 函数作为另一个函数的返回值 12345678910def func(): print('这是第一个函数')def func_two(func): print('这是第二个函数') return funcf = func_two(func)f()# 这是第二个函数# 这是第一个函数 lambda表达式，匿名函数lambda是一个表达式，他的整体架构比def函数简单得多。所以lambda只能封装有限的逻辑。 lambda表达式的作用 lambda函数起到了函数速写的作用。 lambda表达式的格式语法 由于lambda表达式返回的是函数对象(这里构建的是一个函数对象)，所以我们需要使用一个变量去接受它。格式：lambda的一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，之后是一个表达式。 一个参数123res = lambda args : args + 1print(res(1))# 2 多个参数123res = lambda args1,args2 : args1 * args2print(res(6,6))# 36 Map函数map函数接收的是两个参数，一个函数，一个序列，其功能是将序列中的值处理再依次返回至列表内。其返回值为一个迭代器对象。 匿名函数方式12alist = [1,2,3,4,5]ret = map(lambda x:x ** 2,alist) def函数方式12345alist = [1,2,3,4,5]def func(n): return n**2ret = map(func,alist) 这里的返回值是一个迭代器对象，所以我们需要查看迭代器对象的三种方法 第一种123print(list(ret)) #[1, 4, 9, 16, 25]print(tuple(ret)) #(1, 4, 9, 16, 25)print(set(ret)) #&#123;1, 4, 9, 16, 25&#125; 第二种123for i in ret: print(i,end=\" \")# 1 4 9 16 25 第三种1234567#使用循环来获取，但是一直next获取，当获取不到会报无法停止的错误，所以使用try来处理。while True: try: print(next(ret),end=\" \") except StopIteration as e: break# 1 4 9 16 25 Sorted函数sort 与 sorted 区别：sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作,对原list无影响 1234567slist = [1,4,2,5,3]slist.sort()print(slist) # [1,2,3,4,5]alist = [1,4,2,5,3]print(sorted(alist)) # [1,2,3,4,5]print(alist) # [1,4,2,5,3] sorted接收三个参数(iterable,key,reverse)其中reverse=False是降序(默认)，reverse=True是升序 123alist = [1,5,-6,3,4]print(sorted(alist,key=abs,reverse=True))#这里我用了abs绝对值函数#[-6, 5, 4, 3, 1]-6的绝对值是6，所以在第一位 Reduce函数reduce计算过程：先将第一个，第二个元素进行操作，然后把第一二个操作之后的结果和第三个元素进行操作，直到结束 lambda表达式1234567#reduce函数不是内置函数，而是在模块functools中的函数，故需要导包from functools import reduce alist = [1,2,3,4,5]res = reduce(lambda x,y:x+y,alist)print(res)# 15 def函数方式12345def func(a,b): return a*bres = reduce(func,alist)print(res)# 120 Filter函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。filter函数的返回值也是一个可迭代对象 def函数方式12345def func(n): return n % 2 == 1alist = filter(func, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])print(list(alist))# [1,3,5,7,9] lambda表达式123res = filter(lambda a:a%2==1,[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])print(list(res))# [1,3,5,7,9]","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"}]},{"title":"'结合python实现支付宝退款功能'","slug":"结合python实现支付宝退款功能","date":"2020-06-20T09:58:39.000Z","updated":"2020-06-20T10:07:49.286Z","comments":true,"path":"2020/06/20/结合python实现支付宝退款功能/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/20/%E7%BB%93%E5%90%88python%E5%AE%9E%E7%8E%B0%E6%94%AF%E4%BB%98%E5%AE%9D%E9%80%80%E6%AC%BE%E5%8A%9F%E8%83%BD/","excerpt":"有支付就肯定有退款，当交易发生之后一段时间内，由于买家或者卖家的原因需要退款时，卖家可以通过退款接口将支付款退还给买家，支付宝将在收到退款请求并且验证成功之后，按照退款规则将支付款按原路退到买家帐号上。 交易超过约定时间（签约时设置的可退款时间）的订单无法进行退款 支付宝退款支持单笔交易分多次退款，多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。一笔退款失败后重新提交，要采用原来的退款单号。总退款金额不能超过用户实际支付金额。","text":"有支付就肯定有退款，当交易发生之后一段时间内，由于买家或者卖家的原因需要退款时，卖家可以通过退款接口将支付款退还给买家，支付宝将在收到退款请求并且验证成功之后，按照退款规则将支付款按原路退到买家帐号上。 交易超过约定时间（签约时设置的可退款时间）的订单无法进行退款 支付宝退款支持单笔交易分多次退款，多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。一笔退款失败后重新提交，要采用原来的退款单号。总退款金额不能超过用户实际支付金额。 前面已经写过结合python实现支付宝的支付功能。支付宝官方文档：https://opendocs.alipay.com/apis/api_1/alipay.trade.refund 由于之前写的有支付价格和支付宝的订单号，所以我们根据这两个参数，实现退款。 我们之前写的pay.py已经有退款方法了，所以我们需要直接调用就可以了。 在pay.py已经写入123456789101112131415#请求支付宝退款接口def api_alipay_trade_refund(self, refund_amount, out_trade_no=None, trade_no=None, **kwargs): biz_content = &#123; \"refund_amount\": refund_amount &#125; biz_content.update(**kwargs) if out_trade_no: biz_content[\"out_trade_no\"] = out_trade_no if trade_no: biz_content[\"trade_no\"] = trade_no data = self.build_body(\"alipay.trade.refund\", biz_content) url = self.__gateway + \"?\" + self.sign_data(data) r = requests.get(url) html = r.content.decode(\"utf-8\") return html 现在我们需要在写一个退款的视图 12345678910111213def refund(request): #实例化支付类 alipay = get_ali_object() #调用退款方法 order_string = alipay.api_alipay_trade_refund( #订单号，一定要注意，这是支付成功后返回的唯一订单号 out_trade_no=\"20190503214355\", #退款金额，注意精确到分，不要超过订单支付总金额 refund_amount=\"20.00\", #回调网址 notify_url='http://localhost:8000/md_admin/alipayreturn' ) return HttpResponse(order_string) 如果订单号和退款金额正确的话，请求该接口就会返回退款成功的返回值，查看支付宝钱包，相应的退款应该会及时到账","categories":[{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E6%94%AF%E4%BB%98/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E6%94%AF%E4%BB%98/"}]},{"title":"'使用python结合钉钉配置开发自定义机器人'","slug":"使用python结合钉钉配置开发自定义机器人","date":"2020-06-20T08:56:39.000Z","updated":"2020-06-20T10:28:25.005Z","comments":true,"path":"2020/06/20/使用python结合钉钉配置开发自定义机器人/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/20/%E4%BD%BF%E7%94%A8python%E7%BB%93%E5%90%88%E9%92%89%E9%92%89%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"之前使用钉钉做过三方登录,今天我们来说一下使用python结合钉钉做一个钉钉群自定义机器人。 这个功能属于比较极客的功能，它可以将第三方服务的信息聚合到钉钉群中，实现信息的自动化同步，例如：通过聚合Github、Gitlab等源码管理服务，实现源码更新同步；通过聚合Trello、JIRA等项目协调服务，实现项目信息同步；同事，支持Webhook协议的自定义接入，支持更多可能性，例如：将运维报警提醒、自动化测试的结果报告提醒、工作、生活日程安排（上班打卡、下班吃饭、健身、读书、生日、纪念日…）等等的提醒，通过自定义机器人聚合到钉钉中。","text":"之前使用钉钉做过三方登录,今天我们来说一下使用python结合钉钉做一个钉钉群自定义机器人。 这个功能属于比较极客的功能，它可以将第三方服务的信息聚合到钉钉群中，实现信息的自动化同步，例如：通过聚合Github、Gitlab等源码管理服务，实现源码更新同步；通过聚合Trello、JIRA等项目协调服务，实现项目信息同步；同事，支持Webhook协议的自定义接入，支持更多可能性，例如：将运维报警提醒、自动化测试的结果报告提醒、工作、生活日程安排（上班打卡、下班吃饭、健身、读书、生日、纪念日…）等等的提醒，通过自定义机器人聚合到钉钉中。 过关于钉钉机器人网上的一些攻略年代都比较久远，代码很多都基于python2，为了与时俱进，我们尝试用python3.7来开发配置钉钉自定义机器人。 查看机器人官方文档：https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq首先明确一点，钉钉自定义机器人早就不支持在手机端创建了，所以得使用你的pc端或者mac端的钉钉客户端 创建机器人在需要机器人的聊天群界面，点击智能群助手(一个群可以添加6个自定义机器人，而且还得有管理员权限) 我们选择添加机器人 点进去发现好多机器人，各有各的功能，本次我们选择自定义机器人。 钉钉的机器人基于webhook协议，webhook呢是一个api概念,是微服务api的使用范式之一,也被成为反向api,即前端不主动发送请求,完全由后端推送。在添加机器人页面填写一些基本信息。 需要注意的是，在安全设置一栏里，我们选择加签的方式来验证，在此说明一下，钉钉机器人的安全策略有三种，第一种是使用关键字，就是说你推送的消息里必须包含你创建机器人时定义的关键字，如果不包含就推送不了消息，第二种就是使用加密签名，第三种是定义几个ip源，非这些源的请求会被拒绝，综合来看还是第二种又安全又灵活。 创建成功后，系统会分配给你一个webhook地址，这个地址需要保存一下，地址中有唯一的accesstoken 这是我们的钉钉机器人已经添加完成了，于是我们要写入让他进行自动发送消息 使用机器人发送消息123456789101112131415161718192021222324252627282930#导入需要的模块import timeimport hmacimport hashlibimport base64import urllib.parsetimestamp = str(round(time.time() * 1000))secret = '创建机器人的签名'secret_enc = secret.encode('utf-8')string_to_sign = '&#123;&#125;\\n&#123;&#125;'.format(timestamp, secret)string_to_sign_enc = string_to_sign.encode('utf-8')hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()sign = urllib.parse.quote(base64.b64encode(hmac_code))# print(timestamp)# print(sign)import requests,json #导入依赖库headers=&#123;'Content-Type': 'application/json'&#125; #定义数据类型webhook = '你的webhook地址&amp;timestamp='+timestamp+\"&amp;sign=\"+sign#定义要发送的数据#\"at\": &#123;\"atMobiles\": \"['\"+ mobile + \"']\"data = &#123; \"msgtype\": \"text\", \"text\": &#123;\"content\": '我是机器人,这是我发的第一条消息'&#125;, \"isAtAll\": True&#125;res = requests.post(webhook, data=json.dumps(data), headers=headers) #发送post请求print(res.text) 这是我们已经发现机器人可以推送消息了，看效果： 关于发送消息类型和数据格式文本格式12345678910111213&#123; \"msgtype\": \"text\", //文本 \"text\": &#123; \"content\": \"我就是我, 是不一样的烟火@156xxxx8827\" //文本内容 &#125;, \"at\": &#123; //艾特对象 \"atMobiles\": [ \"156xxxx8827\", \"189xxxx8325\" ], \"isAtAll\": false //是否艾特所有人 &#125;&#125; link格式123456789&#123; \"msgtype\": \"link\", \"link\": &#123; \"text\": \"这个即将发布的新版本，创始人xx称它为红树林。而在此之前，每当面临重大升级，产品经理们都会取一个应景的代号，这一次，为什么是红树林\", \"title\": \"时代的火车向前开\", \"picUrl\": \"\", \"messageUrl\": \"https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI\" &#125;&#125; markdown类型12345678910111213&#123; \"msgtype\": \"markdown\", \"markdown\": &#123; \"title\":\"杭州天气\", \"text\": \"#### 杭州天气 @150XXXXXXXX \\n&gt; 9度，西北风1级，空气良89，相对温度73%\\n&gt; ![screenshot](https://img.alicdn.com/tfs/TB1NwmBEL9TBuNjy1zbXXXpepXa-2400-1218.png)\\n&gt; ###### 10点20分发布 [天气](https://www.dingalk.com) \\n\" &#125;, \"at\": &#123; \"atMobiles\": [ \"150XXXXXXXX\" ], \"isAtAll\": false &#125; &#125; 关于类型还有多种及参数，点击https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq/uKPlK查看 检验失信信息针对上边选择设置的三种方式，至少设置其中一种，以进行安全保护。否则会校验不通过 1234567891011121314151617181920212223// 消息内容中不包含任何关键词&#123; \"errcode\":310000, \"errmsg\":\"keywords not in content\"&#125;// timestamp 无效&#123; \"errcode\":310000, \"errmsg\":\"invalid timestamp\"&#125;// 签名不匹配&#123; \"errcode\":310000, \"errmsg\":\"sign not match\"&#125;// IP地址不在白名单&#123; \"errcode\":310000, \"errmsg\":\"ip X.X.X.X not in whitelist\"&#125;","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"钉钉","slug":"钉钉","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E9%92%89%E9%92%89/"}]},{"title":"'关于celery不执行定时任务的问题'","slug":"关于celery不执行定时任务的问题","date":"2020-06-19T13:43:31.000Z","updated":"2020-06-19T14:16:27.887Z","comments":true,"path":"2020/06/19/关于celery不执行定时任务的问题/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/19/%E5%85%B3%E4%BA%8Ecelery%E4%B8%8D%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"使用celery做定时任务时，出现一个错误，就是不执行定时任务。刚开始在在做测试时是每分钟测试，然后我发现并没有执行这个服务。于是在花费了定量时间，然后解决了这个bug。","text":"使用celery做定时任务时，出现一个错误，就是不执行定时任务。刚开始在在做测试时是每分钟测试，然后我发现并没有执行这个服务。于是在花费了定量时间，然后解决了这个bug。 celery定时任务bug就是简单做celery定时任务时，我发现逻辑和代码并没有任何问题，但是就是不启动。于是进行百度，刚开始说的是可能是celery版本的问题，但是发现并不是这个问题。 经过测试，我把crontab中的参数hour去掉，把minute设置每分钟，于是我发现每分钟都会执行。所以可以确定是hour，也就是时区问题。但是机器上的时间和代码里面的时区都没有问题，那可能是celery本身的问题了。 原因默认celery的时区为UTC 解决思路将celery定时任务设置为根据本地时区触发 默认celery的时区为UTC，如果要在django项目中将celery定时任务配置为根据本地时区触发，则需要修改 在settings.py中添加以下代码 12CELERY_TIMEZONE='Asia/Shanghai'CELERY_ENABLE_UTC=False 定时任务代码附上1234567891011121314151617181920212223242526272829#定时任务#导入celery定时模块from celery.schedules import crontabfrom celery import schedules#导入时间模块from datetime import timedeltaCELERY_TIMEZONE='Asia/Shanghai'CELERY_ENABLE_UTC=False# CELERY_BEAT_SCHEDULE = &#123;# #定义定时任务# 'celery_datetime_work':&#123;# 'task':'myapp.tasks.async_test', #任务名称# 'schedule':timedelta(seconds=60)# &#125;# &#125;CELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_datetime_work':&#123; #天气预报结合钉钉机器人 'task': 'myapp.tasks.func', #我的celery任务 #定时任务每天8.30 'schedule': crontab(minute='30',hour=8), &#125;&#125;","categories":[{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/categories/celery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/tags/celery/"}]},{"title":"'hexo博客美化二'","slug":"hexo博客美化二","date":"2020-06-17T13:59:40.000Z","updated":"2020-06-19T03:32:17.344Z","comments":true,"path":"2020/06/17/hexo博客美化二/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/17/hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E4%BA%8C/","excerpt":"前面已经讲过hexo博客的美化，这是继续更新的。","text":"前面已经讲过hexo博客的美化，这是继续更新的。 1.添加背景音乐打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码然后将此代码放到你想要放的地方，比如放在博客的尾部，则打开 \\themes\\layout_partial\\footer.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐 加载页面，最终展示效果 2.添加地图仪它提供网站访客地理信息，可以以2D、3D等形式显示小地球仪 复制代码放到自己想放的地方，比如放在博客的尾部，则打开 \\themes\\layout_partial\\footer.ejs 文件，将复制的HTML代码粘贴进去。 加载页面最终实现效果：","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/tags/hexo/"}]},{"title":"'paypal跨境支付'","slug":"paypal跨境支付","date":"2020-06-17T02:00:58.000Z","updated":"2020-06-17T12:55:46.511Z","comments":true,"path":"2020/06/17/paypal跨境支付/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/17/paypal%E8%B7%A8%E5%A2%83%E6%94%AF%E4%BB%98/","excerpt":"在公司中，支付是必不可缺的的重要系统之一。有的公司如果涉及到境外支付，就一定听说过或使用说PayPal。PayPal支付的优势就是其业务网络遍布全球。目前PayPal的庞大网络覆盖了全球200多个国家，可提供20多种语言服务，并接受100多种货币付款和56种货币提现。同时，还允许在账户中持有25种货币余额。换句话说，只要付款人拥有一个PayPal账户，他就拥有了在200多个国家进行电子支付购物，并在需要服务的时候享受到母语支持的各种便捷服务。","text":"在公司中，支付是必不可缺的的重要系统之一。有的公司如果涉及到境外支付，就一定听说过或使用说PayPal。PayPal支付的优势就是其业务网络遍布全球。目前PayPal的庞大网络覆盖了全球200多个国家，可提供20多种语言服务，并接受100多种货币付款和56种货币提现。同时，还允许在账户中持有25种货币余额。换句话说，只要付款人拥有一个PayPal账户，他就拥有了在200多个国家进行电子支付购物，并在需要服务的时候享受到母语支持的各种便捷服务。 注册PayPal官网账号：https://www.paypal.comPayPal开发者平台：https://developer.paypal.com/developer/accounts/ 注册成功之后，进去PayPal沙盒应用：https://developer.paypal.com/developer/accounts/然后PayPal会默认给我们创建两个账号，一个是商家的，一个是个户的。当然也可以点击Create account自己创建需要的账号 支付业务以个人账户对商户进行支付业务。 应用管理页面：https://developer.paypal.com/developer/applications/ 这时我们可以发现他给我们默认分配了应用。 点击我们的默认应用，我们可以发现应用的client_id和client_secret。 进入我们的账号设置 可以得知我们的个人账号和账号密码 修改我们个人账号的金额，让我们有足以的价格进行购买测试 进行购买测试安装PayPal在python的sdk 1pip install paypalrestsdk 在djagno中新建一个支付视图views.py 1234567891011121314151617181920212223242526272829303132333435url: path('pay/',payment),#跳转import paypalrestsdkdef payment(request): paypalrestsdk.configure(&#123; \"mode\": \"sandbox\", # sandbox代表沙盒 \"client_id\": \"你的client_id\", \"client_secret\": \"你的client_secret\" &#125;) payment = paypalrestsdk.Payment(&#123; \"intent\": \"sale\", \"payer\": &#123; \"payment_method\": \"paypal\"&#125;, \"redirect_urls\": &#123; \"return_url\": \"http://localhost:8000/palpay/pay/\",#支付成功跳转页面 # \"return_url\": \"http://localhost:8000/palpay/pay/?\"+'order='+str(snoworder)+'&amp;uid='+str(uid) #进行加参，到修改 \"cancel_url\": \"http://localhost:3000/paypal/cancel/\"&#125;,#取消支付页面 \"transactions\": [&#123; \"amount\": &#123; \"total\": \"5.00\", \"currency\": \"USD\"&#125;, \"description\": \"这是一个订单测试\"&#125;]&#125;) if payment.create(): print(\"Payment created successfully\") for link in payment.links: if link.rel == \"approval_url\": approval_url = str(link.href) print(\"Redirect for approval: %s\" % (approval_url)) return redirect(approval_url) else: print(payment.error) return HttpResponse(\"支付失败\") 这里解释一下重点参数，return_url是支付成功后回调的页面，paypal会将一个支付者id回传，然后服务端需要验证支付才能真的完成支付，total是付款金额，精确到分，currency是币种，支持多钟类型的货币。 当Django的服务端创建好支付订单后，重定向到paypal的沙盒环境，这时候一定要使用沙盒的个人账号进行登录和支付。支付完成后，会跳回刚刚传过去的回调页面：http://localhost:8000/palpay/pay/?paymentId=PAYID-L3SYORA3C031930S1733650J&amp;token=EC-9TG269735K620131N&amp;PayerID=ETYYRCDN8C3XJ 这里paypal会传过来三个参数，支付id,token和支付者id,然后因为我要修改参数，所以我对回调网址进行加参， 此时，在回调方法里，我们需要通过支付者id进行确认验证支付 1234567891011121314151617181920212223242526272829303132url: path('palpay/pay/',payment_execute),#成功回调def payment_execute(request): paymentid = request.GET.get(\"paymentId\") #支付id payerid = request.GET.get(\"PayerID\") #支付者id order = request.GET.get('order') #获取订单 uid = request.GET.get('uid')#获取用户id print('订单ID:%s,支付者ID:%s，雪花订单号:%s,uid:%s'%(paymentid,payerid,order,uid)) payment = paypalrestsdk.Payment.find(paymentid) if payment.execute(&#123;\"payer_id\": payerid&#125;): if order and payerid and paymentid: order_end = int(order[-1]) print('订单号最后一位',order_end) if int(order_end) &lt; 5 or int(uid[-1]) &lt; 5: order = OrderOne.objects.filter(order=order).first() order.status = 2 order.save() print(\"修改一表订单状态成功\") return redirect('http://localhost:8080/myorder/') else: order = OrderTwo.objects.filter(order=order).first() order.status = 2 order.save() print(\"修改二表订单状态成功\") return redirect('http://localhost:8080/myorder/') return HttpResponse('未获取到单号，请重新购买') else: print(payment.error) # Error Hash return HttpResponse(\"支付失败\") 这时再看我们的个人账户页面，发现已经扣款成功，说明整个流程已经走完。 总结整个支付流程相对支付宝来说，更加的紧凑，但是做支付安全是第一要务，就个人体验（仅是个人体验）层面来说，支付宝在安全方面做的还是要比Paypal略强一些，起码在信用卡欺诈和盗刷方面风控做的更好，在风险保障和赔付方面都有提供保险，当然由于金融环境的差异较大，并不是说Paypal的风控做的不好，只是机制不同，在国外，如果持卡人的信用卡被盗刷，一般发卡组织会让商家去承担责任，而国内只能在交易环节设置更多的验证，本质上说是要持卡人承担责任。这也是为什么支付宝的风控看起来更好的原因。 最后就是关于费率问题，Paypal官方给出的费率是每笔交易收取3.9%+$0.3（根据你的交易流水，比例可以优惠，具体下限看接入者的月营业额度），不过这可是美刀，不得不说这个费率是相当的高，但是国内做境外支付的电商，一般还是要接入Paypal作为支付方式。支付宝的费率基本上在1.2%左右，具体的费率也看交易流水，有实力的下限可以做到基本没有，单纯的看费率似乎支付宝更有优势，但是别忘记了，这样对比是不科学的，因为凡是接入Paypal的都是看中覆盖外币业务的地区，费率则是投资人该考虑的问题了。","categories":[{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E6%94%AF%E4%BB%98/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E6%94%AF%E4%BB%98/"}]},{"title":"'hexo博客美化一'","slug":"hexo博客美化一","date":"2020-06-16T13:31:29.000Z","updated":"2020-06-17T14:00:01.647Z","comments":true,"path":"2020/06/16/hexo博客美化一/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/16/hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E4%B8%80/","excerpt":"本文讲述的是添加博客美化的样式请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。","text":"本文讲述的是添加博客美化的样式请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！ 1.添加卡通人物我在逛别人博客的时候偶然发现右下角居然有一个萌萌的卡通人物，还能根据你鼠标位置摇头，瞬间被吸引到了，赶紧也给自己博客添加一个吧！点击此处进入该项目地址 获取live2d依赖库： 1npm install --save hexo-helper-live2d 输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处，各个模型的预览请访问原作者的博客 1npm install packagename(模型名称) 打开站点目录下的 _config.yml 文件，添加如下代码 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 设置好过后我们就拥有了一个卡通人物 2.添加鼠标点击爱心效果在 \\themes\\source\\js 下新建文件 love.js，在 love.js 文件中添加以下代码 1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在 \\themes\\layout\\layout.ejs 文件末尾添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/love.js\"&gt;&lt;/script&gt; 再次加载页面我们就可以看到点击爱心的特效了 3.添加鼠标点击显示字体效果在 \\themes\\source\\js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码 12345678910111213141516171819202122232425262728293031323334// 鼠标点击特效，文字特效var a_idx = 0;jQuery(document).ready(function($) &#123; $(\"body\").click(function(e) &#123; var a = new Array (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\"); var $i = $(\"&lt;span/&gt;\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; \"z-index\": 5, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": \"#FF0000\" &#125;); $(\"body\").append($i); $i.animate(&#123; \"top\": y - 180, \"opacity\": 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout('delay()', 2000);&#125;);function delay() &#123; $(\".buryit\").removeAttr(\"onclick\");&#125; 可以根据自己喜欢然后替换为其他文字 如果想要每次点击显示的文字为不同颜色，可以将其中 color 值进行如下更改： 1\"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\" 然后在 \\themes\\layout\\layout.ejs 文件末尾添加以下代码： 12&lt;!--单击显示文字--&gt;&lt;script type=\"text/javascript\" src=\"/js/click_show_text.js\"&gt;&lt;/script&gt; 当再次加载页面之后，就可以看到好看的字体特效了 4.添加鼠标点击烟花爆炸效果在 \\themes\\source\\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码： 1\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;; 然后在 \\themes\\layout\\layout.ejs 文件中写入以下代码： 123&lt;canvas class=\"fireworks\" style=\"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;\" &gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/animejs/2.2.0/anime.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js/fireworks.js\"&gt;&lt;/script&gt; 再次加载页面之后，我们的网站就有鼠标点击烟花爆炸效果了 5.添加彩色滚动变换字体在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=\"binft\"&gt;&lt;/div&gt; &lt;script&gt; var binft = function (r) &#123; function t() &#123; return b[Math.floor(Math.random() * b.length)] &#125; function e() &#123; return String.fromCharCode(94 * Math.random() + 33) &#125; function n(r) &#123; for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) &#123; var l = document.createElement(\"span\"); l.textContent = e(), l.style.color = t(), n.appendChild(l) &#125; return n &#125; function i() &#123; var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) &#125; var l = \"\", o = [\"青青陵上柏，磊磊涧中石。\", \"人生天地间，忽如远行客。\",\"斗酒相娱乐，聊厚不为薄。\", \"驱车策驽马，游戏宛与洛。\",\"洛中何郁郁，冠带自相索。\",\"长衢罗夹巷，王侯多第宅。\",\"两宫遥相望，双阙百余尺。\",\"极宴娱心意，戚戚何所迫？\"].map(function (r) &#123; return r + \"\" &#125;), a = 2, g = 1, s = 5, d = 75, b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"], c = &#123; text: \"\", prefixP: -s, skillI: 0, skillP: 0, direction: \"forward\", delay: a, step: g &#125;; i() &#125;; binft(document.getElementById('binft')); &lt;/script&gt; 加载页面最终显示效果为： 6.添加网站运行时间一个比较好的小功能，可以看见自己的博客运行多久了，时间一天天的增加，成就感也会一天天增加的在 \\themes\\layout_partial\\footer.ejs 文件下添加以下代码： 1234567891011121314151617&lt;span id=\"timeDate\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(\"08/10/2018 17:38:00\");//在此处修改你的建站时间，格式：月/日/年 时:分:秒 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = \"0\" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = \"0\" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = \"0\" + snum;&#125; document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行 \"+dnum+\" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; &#125; setInterval(\"createtime()\",250);&lt;/script&gt; 加载页面，展示效果如下： 7.浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \\themes\\source\\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617// 浏览器搞笑标题var OriginTitle = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); &#125; else &#123; $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 其中 funny.ico 是用户切换到其他标签后你网站的图标，favicon.ico 是正常图标，然后在 \\themes\\layout\\layout.ejs 文件中添加如下代码： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=\"text/javascript\" src=\"/js/FunnyTitle.js\"&gt;&lt;/script&gt; 当我们在再次重新加载页面就可以看到: 8.背景添加动态线条效果在 \\themes\\layout\\layout.ejs 文件中添加如下代码： 1234&lt;!--动态线条背景--&gt;&lt;script type=\"text/javascript\"color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt; 其中：color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）opacity：表示线条透明度（0~1），默认：0.5count：表示线条的总数量，默认：150zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 加载页面，展示效果如下： 9.添加网站雪花飘落效果雪花飘落由两个样式，可以选择自己喜欢的样式 实现方法：在 \\themes\\source\\js 目录下新建一个 snow.js 文件，粘贴以下代码： 样式一123456789101112131415161718192021222324252627282930313233343536373839404142/*样式一*/(function($)&#123; $.fn.snow = function(options)&#123; var $flake = $('&lt;div id=\"snowbox\" /&gt;').css(&#123;'position': 'absolute','z-index':'9999', 'top': '-50px'&#125;).html('&amp;#10052;'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : \"#AFDAEF\" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ &#125;, options = $.extend(&#123;&#125;, defaults, options); var interval= setInterval( function()&#123; var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css(&#123; left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,'linear',function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ &#125;);&#125;); 样式二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*样式二*//* 控制下雪 */function snowFall(snow) &#123; /* 可配置属性 */ snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123; /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function() &#123; snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function() &#123; var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) &#123; this.velY = this.speed &#125; this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, \"rgba(255, 255, 255, 0.9)\"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, \"rgba(255, 255, 255, 0.5)\"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, \"rgba(255, 255, 255, 0)\"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123; var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;/* 画雪 */function drawSnow() &#123; var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start(); 然后在 \\themes\\layout\\layout.ejs 文件里引用即可： 12&lt;!-- 雪花特效 --&gt;&lt;script type=\"text/javascript\" src=\"\\js\\snow.js\"&gt;&lt;/script&gt; 如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可： 12&lt;script type=\"text/javascript\" src=\"http://libs.baidu.com/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://libs.baidu.com/jquery/1.8.3/jquery.min.js\"&gt;&lt;/script&gt; 原文链接：《分享两种圣诞节雪花特效JS代码(网站下雪效果)》 10.添加背景代码雨特效在 \\themes\\source\\js 目录下新建一个 DigitalRain.js 的文件，里面写入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657window.onload = function()&#123; //获取画布对象 var canvas = document.getElementById(\"canvas\"); //获取画布的上下文 var context =canvas.getContext(\"2d\"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++)&#123; drops.push(0); &#125; //运动的文字 var str =\"WELCOME TO WWW.ITRHX.COM\"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw()&#123; context.fillStyle = \"rgba(238,238,238,.08)\";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = \"600 \"+fontSize+\"px Georgia\"; //给字体添加颜色 context.fillStyle = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++)&#123; var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123; drops[i] = 0; &#125; drops[i]++; &#125; &#125;; function randColor()&#123;//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\"+r+\",\"+g+\",\"+b+\")\"; &#125; draw(); setInterval(draw,35);&#125;; 在主题文件的相关css文件中（在\\themes\\source\\less_main.less 文件末尾）添加以下代码： 12345678910canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125; 在\\themes\\layout\\layout.ejs 文件中写入 123&lt;!-- 数字雨 --&gt;&lt;canvas id=\"canvas\" width=\"1440\" height=\"900\" &gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\" src=\"/js/DigitalRain.js\"&gt;&lt;/script&gt; 最终效果","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/tags/hexo/"}]},{"title":"'结合js做md5加密'","slug":"结合js做md5加密","date":"2020-06-16T09:48:47.000Z","updated":"2020-06-20T10:29:37.800Z","comments":true,"path":"2020/06/16/结合js做md5加密/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/16/%E7%BB%93%E5%90%88js%E5%81%9Amd5%E5%8A%A0%E5%AF%86/","excerpt":"不管在前端还是后端，我们都会有一些简单的业务对数据进行加密处理，用来防止信息等被盗取，所以我们这里来使用md5加密。 关于md5加密算法MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。","text":"不管在前端还是后端，我们都会有一些简单的业务对数据进行加密处理，用来防止信息等被盗取，所以我们这里来使用md5加密。 关于md5加密算法MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。 md5依赖库123npm install js-md5# \"js-md5\": \"^0.7.3\", 针对md5加密库，因为他不是热库，不需要经常被使用，所以不需要将它加入到main.js中。最好的结果是每次使用单独对他进行调用。 1import md5 from 'js-md5' 前端代码示例1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &#123;&#123;total&#125;&#125; &lt;!-- 7b7a53e239400a13bd6be6c91c4f6c4e --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import md5 from 'js-md5'export default &#123; data () &#123; return &#123; total:'', &#125; &#125;, //注册组件标签 components:&#123; &#125;, mounted:function()&#123; var num = '2020' this.total = md5(num) &#125;, methods:&#123; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 打印结果:7b7a53e239400a13bd6be6c91c4f6c4e 后端代码示例12345678910111213141516171819202122232425import hashlib#前端numnum = '2020'#前端传的signsign = \"7b7a53e239400a13bd6be6c91c4f6c4e\"#实例化md5 = hashlib.md5()#组合要加密的字符串sign_str = num#解码mysign = str(sign_str).encode(encoding=\"utf-8\")#设置加密md5.update(mysign)mysign = md5.hexdigest()#判断print(mysign)if sign == mysign: print(\"签名一致\")else: print(\"数据被篡改\")#打印结果：7b7a53e239400a13bd6be6c91c4f6c4e#签名一致 针对需要保密的信息，使用md5进行加密一下简直不要太完美。","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"}]},{"title":"'结合python实现支付宝支付功能'","slug":"结合python实现支付宝支付功能","date":"2020-06-16T08:39:30.000Z","updated":"2020-06-20T09:59:06.685Z","comments":true,"path":"2020/06/16/结合python实现支付宝支付功能/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/16/%E7%BB%93%E5%90%88python%E5%AE%9E%E7%8E%B0%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/","excerpt":"现在所有的门户网站还是一下应用，都离不开第三方支付，我们今天讲一下第三方的支付接口也就是支付宝接口付款。支付宝支付采用了RSA加密签名的安全通信机制，开发者可以通过支付宝的公钥验证消息的来源，同时使用自己的私钥进行信息加密。RSA算法及数字签名机制是服务窗平台与开发者网关安全通信的基础。","text":"现在所有的门户网站还是一下应用，都离不开第三方支付，我们今天讲一下第三方的支付接口也就是支付宝接口付款。支付宝支付采用了RSA加密签名的安全通信机制，开发者可以通过支付宝的公钥验证消息的来源，同时使用自己的私钥进行信息加密。RSA算法及数字签名机制是服务窗平台与开发者网关安全通信的基础。 支付宝付款流程图 沙箱在使用支付宝支付的时候，我们就要使用到沙箱功能。支付宝沙箱网址：https://openhome.alipay.com/platform/appDaily.htm?tab=info 在沙箱应用中，我们需要记住自己的APPID,设置RSA2(SHA256)密钥设置密钥官方文档：https://opendocs.alipay.com/open/291/105971#LDsXr 根据文档生成自己的应用公钥和密钥。 实现支付宝接口接入创建一个keys文件夹，存放alipay_public_2048.txt支付宝公钥和app_private_2048.txt应用私钥 文档地址：https://docs.open.alipay.com/api 根据文档写一个支付基类pay.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142from datetime import datetimefrom Crypto.PublicKey import RSAfrom Crypto.Signature import PKCS1_v1_5from Crypto.Hash import SHA256from urllib.parse import quote_plusfrom urllib.parse import urlparse, parse_qsfrom base64 import decodebytes, encodebytesimport jsonimport requestsclass AliPay(object): \"\"\" 支付宝支付接口(PC端支付接口) \"\"\" def __init__(self, appid, app_notify_url, app_private_key_path, alipay_public_key_path, return_url, debug=False): self.appid = appid self.app_notify_url = app_notify_url self.app_private_key_path = app_private_key_path self.app_private_key = None self.return_url = return_url with open(self.app_private_key_path) as fp: self.app_private_key = RSA.importKey(fp.read()) self.alipay_public_key_path = alipay_public_key_path with open(self.alipay_public_key_path) as fp: self.alipay_public_key = RSA.importKey(fp.read()) #debug=True为测试模式，false是上线模式 if debug is True: self.__gateway = \"https://openapi.alipaydev.com/gateway.do\" else: self.__gateway = \"https://openapi.alipay.com/gateway.do\" def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs): biz_content = &#123; \"subject\": subject, \"out_trade_no\": out_trade_no, \"total_amount\": total_amount, \"product_code\": \"FAST_INSTANT_TRADE_PAY\", # \"qr_pay_mode\":4 &#125; biz_content.update(kwargs) data = self.build_body(\"alipay.trade.page.pay\", biz_content, self.return_url) return self.sign_data(data) #构造参数体 def build_body(self, method, biz_content, return_url=None): data = &#123; \"app_id\": self.appid, \"method\": method, \"charset\": \"utf-8\", \"sign_type\": \"RSA2\", \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"), \"version\": \"1.0\", \"biz_content\": biz_content &#125; if return_url is not None: data[\"notify_url\"] = self.app_notify_url data[\"return_url\"] = self.return_url return data #签名数据 def sign_data(self, data): data.pop(\"sign\", None) # 排序后的字符串 unsigned_items = self.ordered_data(data) unsigned_string = \"&amp;\".join(\"&#123;0&#125;=&#123;1&#125;\".format(k, v) for k, v in unsigned_items) sign = self.sign(unsigned_string.encode(\"utf-8\")) # ordered_items = self.ordered_data(data) quoted_string = \"&amp;\".join(\"&#123;0&#125;=&#123;1&#125;\".format(k, quote_plus(v)) for k, v in unsigned_items) # 获得最终的订单信息字符串 signed_string = quoted_string + \"&amp;sign=\" + quote_plus(sign) return signed_string #订单数据 def ordered_data(self, data): complex_keys = [] for key, value in data.items(): if isinstance(value, dict): complex_keys.append(key) # 将字典类型的数据dump出来 for key in complex_keys: data[key] = json.dumps(data[key], separators=(',', ':')) return sorted([(k, v) for k, v in data.items()]) def sign(self, unsigned_string): # 开始计算签名 key = self.app_private_key signer = PKCS1_v1_5.new(key) signature = signer.sign(SHA256.new(unsigned_string)) # base64 编码，转换为unicode表示并移除回车 sign = encodebytes(signature).decode(\"utf8\").replace(\"\\n\", \"\") return sign def _verify(self, raw_content, signature): # 开始计算签名 key = self.alipay_public_key signer = PKCS1_v1_5.new(key) digest = SHA256.new() digest.update(raw_content.encode(\"utf8\")) if signer.verify(digest, decodebytes(signature.encode(\"utf8\"))): return True return False def verify(self, data, signature): if \"sign_type\" in data: sign_type = data.pop(\"sign_type\") # 排序后的字符串 unsigned_items = self.ordered_data(data) message = \"&amp;\".join(u\"&#123;&#125;=&#123;&#125;\".format(k, v) for k, v in unsigned_items) return self._verify(message, signature) #请求退款接口 def api_alipay_trade_refund(self,refund_amount,out_trade_no=None,trade_no=None,**kwargs): #构造参数体 biz_content = &#123; \"refund_amount\":refund_amount&#125; #传递可选参数 biz_content.update(**kwargs) #判断使用站外订单还是支付宝订单 if out_trade_no: biz_content[\"out_trade_no\"] = out_trade_no if trade_no: biz_content[\"trade_no\"] = trade_no #构造支付接口地址 data = self.build_body(\"alipay.trade.refund\",biz_content) #构造url url = self.__gateway+\"?\" + self.sign_data(data) #请求接口 r = requests.get(url) html = r.content.decode(\"utf-8\") return html 在视图定义方法使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465配置路由 path('pay_url/',pay_url),#支付宝跳转视图 path('testpay/',back_url),#会调地址import timeimport osfrom django.shortcuts import render,redirect#导入公共目录变量from mydjango.settings import BASE_DIRfrom django.http import HttpResponse#导入支付宝支付接口from mydjango.pay import AliPay#引入支付宝沙箱秘钥#应用私钥app_private_key_string = os.path.join(BASE_DIR,'keys/app_private_2048.txt')#支付宝公钥alipay_public_key_string = os.path.join(BASE_DIR,'keys/alipay_public_2048.txt')#建立支付实例def get_ali_object(): app_id = '你的沙箱应用ID' #沙箱应用ID #支付完成后跳转的地址 return_url = 'http://localhost:8000/testpay/' alipay = AliPay( appid = app_id, app_notify_url = return_url, return_url = return_url, app_private_key_path = app_private_key_string, alipay_public_key_path = alipay_public_key_string, #支付宝公钥,验证支付宝回传消息，不是自己公钥 debug=True,#默认false ) return alipay#支付跳转视图def pay_url(request): alipay = get_ali_object() #生成支付的url query_params = alipay.direct_pay( subject='test',#商品简单描述 out_trade_no='myorder'+str(time.time()),#订单号，这里使用的是时间戳来做 total_amount= 100.00#交易金额（单元：元 保留两位小数） ) pay_url = 'https://openapi.alipaydev.com/gateway.do?' + query_params return redirect(pay_url) # return HttpResponse('123')#回调网址def back_url(request): return HttpResponse('回调成功')#回调url#http://localhost:8080/myorder?charset=utf-8&amp;out_trade_no=4370479805276098561&amp;method=alipay.trade.page.pay.return&amp;total_amount=200.00&amp;sign=LCsKfD3ybvAlhzj1%2BJszACsy%2FeOL18p0A%2FmBIa68ZH2SUNb6163FWP5ScmyrGliBlmEtRVcVPkGASVLiY5l5ESTvFkx7OX3FO9%2FtqPRopSvhnf6jaaPjJt90YcG69Z9XZaqJHlK7LqCocLRKSXb4zxWDpek8QRrpUmkn9gxJgKr64Z7%2FlcjsZMpr1SxGjEhyMZp%2FbgcZfD8X4%2BiUkZThXB1LkKNhcRG5gHZTfoiEj%2FKxOFyH%2BNs4klXFjDTe5217UVMUAE351qfq0%2F%2FCXcZ3aHW52XobDAs12J6eVVtijUr8v2xD%2Bpp5SlgCBhkXt86euH4iVfLn61%2FCOMU7b3HLJQ%3D%3D&amp;trade_no=2020061622001482770501026654&amp;auth_app_id=2016092600603658&amp;version=1.0&amp;app_id=2016092600603658&amp;sign_type=RSA2&amp;seller_id=2088102177418159&amp;timestamp=2020-06-16%2013%3A27%3A16#回调网址中的参数# out_trade_no=4370479805276098561 #订单号# total_amount=200.00 #订单价格#sign='LCsKfD3ybvAlhzj1%2BJszACsy%2FeOL18p0A%2FmBIa68ZH2SUNb6163FWP5ScmyrGliBlmEtRVcVPkGASVLiY5l5ESTvFkx7OX3FO9%2FtqPRopSvhnf6jaaPjJt90YcG69Z9XZaqJHlK7LqCocLRKSXb4zxWDpek8QRrpUmkn9gxJgKr64Z7%2FlcjsZMpr1SxGjEhyMZp%2FbgcZfD8X4%2BiUkZThXB1LkKNhcRG5gHZTfoiEj%2FKxOFyH%2BNs4klXFjDTe5217UVMUAE351qfq0%2F%2FCXcZ3aHW52XobDAs12J6eVVtijUr8v2xD%2Bpp5SlgCBhkXt86euH4iVfLn61%2FCOMU7b3HLJQ%3D%3D'#签名# trade_no=2020061622001482770501026654 #支付宝订单号# auth_app_id=2016092600603658 #应用ID# version=1.0 #版本# sign_type='RSA2' #算法# seller_id=2088102177418159 #支付者ID# timestamp='2020-06-16%2013%3A27%3A16'#时间戳 在沙箱账号中，有个买家和卖家账号，在使用沙箱做测试支付的时候，使用的是买家账号，账号密码还有登陆密码都有说明，还需要充值买家账号余额，这里的金钱都是虚拟的。这样就可以完成测试支付宝付款了。快去测试一波吧！！","categories":[{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E6%94%AF%E4%BB%98/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E6%94%AF%E4%BB%98/"}]},{"title":"'分布式ID雪花算法(snowflake)'","slug":"雪花算法-snowflake","date":"2020-06-14T09:43:19.000Z","updated":"2020-06-20T10:26:13.950Z","comments":true,"path":"2020/06/14/雪花算法-snowflake/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/14/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-snowflake/","excerpt":"唯一ID可以标识数据的唯一性，在分布式系统中生成唯一ID的方案有很多，常见的方式大概有以下三种： 依赖数据库，使用如MySQL自增列或Oracle序列等。根据UUID生成snowflake雪花算法","text":"唯一ID可以标识数据的唯一性，在分布式系统中生成唯一ID的方案有很多，常见的方式大概有以下三种： 依赖数据库，使用如MySQL自增列或Oracle序列等。根据UUID生成snowflake雪花算法 为什么使用snowflake生成ID使用uuid生成订单号这类东西也能凑合用，但是它有着罄竹难书的“罪行”：肉眼可见，它是无序的；长度是64位数字字母随机组合的字符串，占用空间巨大；完全不具备业务属性，也就是说使用uuid你完全无法推算出它到底是干嘛的；因为无序，所以趋势递增就更不用指望了；所以用uuid生成订单号就是自杀行为，适合它的是类似生成token令牌的场景。 雪花算法(snowflake)是Twitter开源的分布式ID生成算法，结果是一个long型的ID。为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序，让twitter可以通过一定的索引来进行检索，而在Twitter庞大的分布式系统中不同机器产生的id必须又必须不同。它的好处显而易见，不仅全局唯一，并且有序按时间递增，同时占用空间少，生成的id仅仅是19位的整形数字，正好契合mysql的bigint数据类型，简直完美。 核心思想其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。组成： 优势整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。 可以根据自身业务特性分配bit位，非常灵活。 缺陷强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。 安装库1pip install pysnowflake 开启服务1snowflake_start_server --work&#x3D;1 12指定端口开启服务snowflake_start_server --work=1 --port=端口号 服务信息123456import snowflake.clientprint(snowflake.client.get_stats())#worker是服务信息,time是时间戳#&#123;'dc': 0, 'worker': 1, 'timestamp': 1592131606294, 'last_timestamp': 550281600000, 'sequence': 0, 'sequence_overload': 0, 'errors': 0&#125; 获取ID12345import snowflake.clientprint(snowflake.client.get_guid())#4369836784469676033 根据ID反解析服务123456789101112131415import snowflake.clientsid = snowflake.client.get_guid()print(sid)#ID：4369838396760133633bid = bin(sid)print(bid)#第一位是标识符，此后是41位的时间戳，紧接着10位的节点标识码，最后12位的递增序列，# 从后面数12位是：000000000001，再数5位是：00001 这5位就是某个节点的存储标识，我们就二进制的00001转换为十进制#0b11110010100100110010001101111010010100110000000001000000000001cid = bin(sid)[47:52]print('存储节点',cid)#存储节点 00001print('反解析服务',int(cid,2))#反解析服务 1 使用bigint存储在使用好处显而易见，不仅全局唯一，并且有序按时间递增，同时占用空间少，生成的id仅仅是19位的整形数字，正好契合mysql的bigint数据类型，简直完美。但是使用bigint有个bug，就是19位数字传到前端会发生关于js数字精度丢失问题。关于精度丢失问题","categories":[{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'关于js数字过长出现的精度丢失问题'","slug":"关于js数字过长出现的精度丢失问题","date":"2020-06-14T07:37:27.000Z","updated":"2020-06-20T10:27:58.249Z","comments":true,"path":"2020/06/14/关于js数字过长出现的精度丢失问题/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/14/%E5%85%B3%E4%BA%8Ejs%E6%95%B0%E5%AD%97%E8%BF%87%E9%95%BF%E5%87%BA%E7%8E%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/","excerpt":"在JavaScript中，由于计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示。js的整数和浮点数都属于Number类型的，所有数字都是以64位浮点数形式存储。所以我们在前端打印的时候，发现一个很奇怪的问题，就是当console.log(1.00)时，我们发现打印结果是1,后边的.00都被舍去。虽然数值是正确的，但是和理想结果有些偏差。","text":"在JavaScript中，由于计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示。js的整数和浮点数都属于Number类型的，所有数字都是以64位浮点数形式存储。所以我们在前端打印的时候，发现一个很奇怪的问题，就是当console.log(1.00)时，我们发现打印结果是1,后边的.00都被舍去。虽然数值是正确的，但是和理想结果有些偏差。 针对雪花算法出现的问题在做雪花算法的时候，说过使用model中的bigint是最好的存储方式，但是在做的时候发现一个问题，就是在前端展示出现展示效果问题，话不多说，上代码 这是我保存数据库的结果 这是我后端获取数据 这是我前端获取数据的结果 但是在我前端获取数据结果的时候，发现了一件很怪异的事情，就是js自动将我的数据给修改了，也就是前16位都是对着的。经过测试发现，我的后端数据没有问题，在传递给前端的时候出现了差错，经过咨询和百度，发现了是js精度丢失的问题。最常用的解决办法就是使用字符串类型。于是我把数据库的bitint类型给改成了varchar。完美解决。 JavaScript的16位长度数字不变，超过就发生精度丢失问题。针对数字丢失问题，我做了实验。 16位数字没变12345mounted()&#123; console.log('最大安全数',1111111111111111)&#125;// 最大安全数 1111111111111111 17位发生变化12345mounted()&#123; console.log('最大安全数',11111111111111111)&#125;// 最大安全数 11111111111111112 20位发生变化1234mounted()&#123; console.log('最大安全数',11111111111111111111)&#125;// 最大安全数 11111111111111110000 根据以上代码，我们可以清晰看到在16位整数可以发现数字没有变化，但是在第17位的时候就发生了变化，长度越长后边都以0显示。 解决办法:对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）","categories":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"},{"name":"js","slug":"js","permalink":"https://wzh3683.github.io/hexo_blog/tags/js/"}]},{"title":"'uuid生成唯一id'","slug":"uuid生成唯一id","date":"2020-06-14T07:36:27.000Z","updated":"2020-06-20T10:14:23.247Z","comments":true,"path":"2020/06/14/uuid生成唯一id/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/14/uuid%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80id/","excerpt":"当我们在做订单号的时候，可以发现我们使用订单号有个硬性条件，就是它最好的唯一性的,且最好是自增长。在我们python中，系统自带了一个唯一的模块，就是uuid。但是我们使用uuid来生成订单号虽然也能使用，但是却有一个致命的缺点，就是无序。","text":"当我们在做订单号的时候，可以发现我们使用订单号有个硬性条件，就是它最好的唯一性的,且最好是自增长。在我们python中，系统自带了一个唯一的模块，就是uuid。但是我们使用uuid来生成订单号虽然也能使用，但是却有一个致命的缺点，就是无序。 关于UUID(univeral unique identifier)uuid是128位的全局唯一标识符（univeral unique identifier），通常用32位的一个字符串的形式来表现。python中自带了uuid模块来进行uuid的生成和管理工作。在python中的uuid模块是基于MAC地址、时间戳、命名空间、随机数、伪随机数来生成的。 uuid.uuid1() 基于MAC地址，时间戳，随机数来生成唯一的uuid，可以保证全球范围内的唯一性。 1234import uuidprint(uuid.uuid1())#b8200238-ae14-11ea-859b-68ecc5357e24 uuid.uuid2() uuid.uuid2()算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。不过需要注意的是python中没有基于DCE的算法，所以python的uuid模块中没有uuid2这个方法。 uuid.uuid3() 通过计算一个命名空间和名字的md5散列值来给出一个uuid，所以可以保证命名空间中的不同名字具有不同的uuid，但是相同的名字就是相同的uuid了。namespace并不是一个自己手动指定的字符串或其他量，而是在uuid模块中本身给出的一些值。比如uuid.NAMESPACE_DNS，uuid.NAMESPACE_OID，uuid.NAMESPACE_OID这些值。这些值本身也是UUID对象，根据一定的规则计算得出。 1234567import uuidname = 'uuid_name'namespace = uuid.NAMESPACE_URLprint(uuid.uuid3(namespace,name))#5b4c833b-b8f0-36de-84d3-5ab20550d1c6 uuid.uuid4() 通过伪随机数得到uuid，是有一定概率重复的 12345import uuidprint(uuid.uuid4())#1c0f445e-a357-4568-a9bc-25e0b4c07330 uuid.uuid5() 和uuid3基本相同，只不过采用的散列算法是sha1 1234567import uuidname = 'uuid_name'namespace = uuid.NAMESPACE_URLprint(uuid.uuid5(namespace,name))#87fec518-b116-571f-87e3-e40ab834ff45","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"}]},{"title":"'使用又拍云及拖拽上传'","slug":"day10-vue+django+python完成又拍云实现拖拽存储","date":"2020-06-09T02:28:35.000Z","updated":"2020-06-20T10:26:53.774Z","comments":true,"path":"2020/06/09/day10-vue+django+python完成又拍云实现拖拽存储/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/09/day10-vue+django+python%E5%AE%8C%E6%88%90%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E5%AD%98%E5%82%A8/","excerpt":"官方网址：又拍云官网 1.点击注册或登录","text":"官方网址：又拍云官网 1.点击注册或登录 2.点击云存储 3.创建服务 4.查看又拍云图片 4.1分配的网址/图片名 http://md-upyun.test.upcdn.net/图片名 4.2进入文件管理查看 5.添加操作员 6.添加操作员 下载依赖 1pip install upyun 使用又拍云下载大文件1234567import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#文件流操作(节省内存)with open('./bg.png','rb') as f: #上传文件 res = up.put('/bg.png',f,checksum=True) 使用又拍云进行写入文件12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')value = 'hello python,恩呢恩'up.put('/yun.txt',value) 使用又拍云进行目录操作，创建文件夹12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#目录操作,创建文件夹up.mkdir('/ypyun_test/') 使用又拍云移动文件123456import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#移动文件#src移动谁，dest移动到哪up.move('bg.png','/ypyun_test/bg.png') 使用又拍云复制文件12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#复制文件up.copy('9c1d0bd8-8f51-11ea-a567-005056c00008.jpg','/ypyun_test/9c1d0bd8-8f51-11ea-a567-005056c00008.jpg') 使用又拍云断点续传1234567import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#断点续传(第二次传的时候是从第一次剩下的开始继续上传)with open('D:\\学习资料\\视频\\猫和老鼠.mp4','rb') as f:# need_resume=True断点续传 res = up.put('/ypyun_test/猫和老鼠.mp4',f,checksum=True,need_resume=True) 使用又拍云进行下载123456import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#下载图片res = up.get('/ypyun_test/9c1d0bd8-8f51-11ea-a567-005056c00008.jpg')print(res) 使用又拍云进行删除12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#删除up.delete('/ypyun_test/9c1d0bd8-8f51-11ea-a567-005056c00008.jpg') 拖拽上传代码示例vue代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;template&gt; &lt;div&gt; &lt;input type=\"file\" @change=\"upload_upyun\" /&gt; &lt;div class=\"upload\"&gt; 拖拽上传 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return&#123; &#125; &#125;, mounted () &#123; let upload = document.querySelector('.upload'); upload.addEventListener('dragenter', this.onDrag, false); upload.addEventListener('dragover', this.onDrag, false); upload.addEventListener('drop', this.onDrop, false); &#125;, //自定义方法 methods:&#123; onDrag (e) &#123; e.stopPropagation(); e.preventDefault(); &#125;, onDrop (e) &#123; e.stopPropagation(); e.preventDefault(); this.upload_upyun(e.dataTransfer.files); &#125;, //上传又拍云 upload_upyun:function(files)&#123; //获取文件对象 // let file = e.target.files[0]; let file = files[0]; //声明参数 let param = new FormData(); param.append('file',file); const config = &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125; this.axios(&#123; url:'http://localhost:8000/ypy/', method:'POST', data:param, config:config &#125;).then(resp=&gt;&#123; console.log(resp) &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.upload &#123; margin: 100px auto; width: 300px; height: 150px; border: 2px dashed #f00;&#125;&lt;/style&gt; django代码： 12345678910111213141516171819urls： path('ypy/',UpyunLoad.as_view()),import upyun# 定义文件上传类class UpyunLoad(APIView): def post(self, request): #前端获取文件 img = request.FILES.get('file') #创建文件名 file_name = str(uuid.uuid1())+'.jpg' print(file_name) up = upyun.UpYun('你的空间服务名称', username='操作员', password='生成密码') #x-gmkerl-rotate 旋转角度，目前只允许设置：auto，90，180，270 headers = &#123;'x-gmkerl-rotate': 'auto'&#125; for chunk in img.chunks(): res = up.put('/%s'%file_name, chunk, checksum=True, headers=headers) # 返回结果 return Response(&#123;'filename': file_name&#125;)","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"},{"name":"又拍云","slug":"又拍云","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"}]},{"title":"'结合又拍云实现多线程异步分块上传'","slug":"结合又拍云实现多线程异步分块上传","date":"2020-06-09T02:28:35.000Z","updated":"2020-06-20T10:29:22.625Z","comments":true,"path":"2020/06/09/结合又拍云实现多线程异步分块上传/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/09/%E7%BB%93%E5%90%88%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E5%88%86%E5%9D%97%E4%B8%8A%E4%BC%A0/","excerpt":"上一篇我们已经说过又拍云的常用操作,今天我们讲一下结合多线程实现异步上传 当我们使用第三方依赖，要注意模块是不是最新依赖，进行更新 UPYUN Python SDK文档：点击跳转查看最新python SDK：点击跳转","text":"上一篇我们已经说过又拍云的常用操作,今天我们讲一下结合多线程实现异步上传 当我们使用第三方依赖，要注意模块是不是最新依赖，进行更新 UPYUN Python SDK文档：点击跳转查看最新python SDK：点击跳转 多线程异步实现又拍云上传1234567891011121314151617181920212223242526272829303132import upyun # 又拍云import os # 文件模块import threading # 多线程模块# 新建又拍云实例# 三个参数,又拍云服务名称，操作员名称，操作员密码up = upyun.UpYun('服务名称', '操作员名称', '操作员密码')# 分块上传uploader = up.init_multi_uploader('/upyun_python/upyun_sanguo.mp4')#同步上传# uploader.upload(0,os.urandom(1024*1024))# uploader.upload(1,os.urandom(1024*1024))#采用多线程调用上传#创建线程池threads = []#uploader.upload不加括号，这里是声明，不是调用，调用的话还是同步#参数写在args里,(0声明异步上传序号)t1 = threading.Thread(target=uploader.upload,args=(0,os.urandom(1024*1024)))# #添加到线程池threads.append(t1)t2 = threading.Thread(target=uploader.upload,args=(1,os.urandom(1024*1024)))threads.append(t2)#启动多线程for t in threads: t.start()# #阻塞主线程 t.join()## # #声明调用结束res = uploader.complete() 多线程异步对文件进行分块上传123456789101112131415161718#上传又拍云文件class Upyun_Post(APIView): def post(self,request): # 获取视频文件 file = request.FILES.get('file') print(file) up = upyun.UpYun('服务名称', '操作员名称', '操作员密码') uploader = up.init_multi_uploader(\"/upyun-python-sdk/%s\" % file, part_size=(1024 * 2048)) threads = [] for index, value in enumerate(file.chunks(chunk_size=(1024 * 2048))): t = threading.Thread(target=uploader.upload, args=(index, value)) threads.append(t) for i in threads: i.start() i.join() res = uploader.complete() return Response(&#123;'code':200,'message':'上传成功'&#125;) # return HttpResponse(json.dumps(&#123;'filename': file&#125;), content_type='application/json')","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"又拍云","slug":"又拍云","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"多线程","slug":"多线程","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"异步","slug":"异步","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"'响应状态码和请求方法'","slug":"响应状态码","date":"2020-06-08T10:28:33.000Z","updated":"2020-06-20T10:20:19.999Z","comments":true,"path":"2020/06/08/响应状态码/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/08/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"状态码分类(HTTP Status Code)123451XX- 信息型，服务器收到请求，需要请求者继续操作。2XX- 成功型，请求成功收到，理解并处理。3XX - 重定向，需要进一步的操作以完成请求。4XX - 客户端错误，请求包含语法错误或无法完成请求。5XX - 服务器错误，服务器在处理请求的过程中发生了错误。","text":"状态码分类(HTTP Status Code)123451XX- 信息型，服务器收到请求，需要请求者继续操作。2XX- 成功型，请求成功收到，理解并处理。3XX - 重定向，需要进一步的操作以完成请求。4XX - 客户端错误，请求包含语法错误或无法完成请求。5XX - 服务器错误，服务器在处理请求的过程中发生了错误。 常用状态码12345678910111213141516171819100系列： 100 继续 客户端应当继续发送请求200系列： 200 成功 服务器成功处理了请求300系列： 301 永久移动 请求的网页已永久移动到新位置，永久重定向 302 临时移动 请求的网页暂时跳转到其他页面，临时重定向400系列： 400 错误请求 服务器无法解析该请求 401 未授权 请求没有进行身份验证或验证未通过 403 禁止访问 服务器拒绝此请求 404 未找到 服务器找不到请求的网页500系列： 500 服务器内部错误 服务器遇到错误，无法完成请求 501 未实现 服务器不具备完成请求的功能 502 错误网关 服务器做为网关或代理，从上游服务器收到无效响应 504 网关超时 服务器做为网关或代理，但是没有及时从上游服务器收到请求 505 HTTP版本不支持 服务器不支持请求中所用的HTTP协议版本 请求方法1234567891011121314151).GET：请求页面，并返回页面内容 2).POST：用于提交表单数据或上传文件，数据包含在请求体中3).PUT：从客户端向服务器传送的数据取代指定文档中的内容4).DELETE：请求服务器删除指定的页面5).CONNECT：把服务器当做跳板，让服务器代替客户端访问其他网页6).HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头7).OPTIONS：允许客户端查看服务器的性能8).TRACE：回显服务器收到的请求，主要用于测试或诊断#重点掌握GET&amp;POST区别： 1.GET请求中的参数包含在URL里面，数据可以在URL中看到。而POST请求的URL不会包含这些数据，POST的数据都是通过表单形式传输的，会包含在请求体中。 2.GET请求提交的数据最多之后1024字节，而POST方式没有限制 3.POST请求比GET请求相对安全。 请求响应步骤1客户端连接到Web服务器-&gt;发送Http请求-&gt;服务器接受请求并返回HTTP响应-&gt;释放连接TCP连接-&gt;客户端浏览器解析HTML内容","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"协议","slug":"协议","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"'HTTP协议和HTTPS协议'","slug":"HTTP协议和HTTPS协议","date":"2020-06-08T09:21:21.000Z","updated":"2020-06-20T10:20:28.771Z","comments":true,"path":"2020/06/08/HTTP协议和HTTPS协议/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/08/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE/","excerpt":"HTTP协议和HTTPS协议的概念1234567HTTP协议(Hyper Text Transfer Protocol)：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）， 用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS协议：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层， HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种： 1.一种是建立一个信息安全通道，来保证数据传输的安全； 2.另一种就是确认网站的真实性。","text":"HTTP协议和HTTPS协议的概念1234567HTTP协议(Hyper Text Transfer Protocol)：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）， 用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS协议：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层， HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种： 1.一种是建立一个信息安全通道，来保证数据传输的安全； 2.另一种就是确认网站的真实性。 HTTP协议的缺点1234HTTP缺点： 1.通信使用明文，内容可能被窃听(重要密码泄露) 2.不验证通信方身份，有可能遭遇伪装(跨站点请求伪造) 3.无法证明报文的完整性，有可能已遭篡改(运营商劫持) http和https的区别与联系及特点123456789101112 HTTP协议是超文本传输协议，被用于在Web浏览器和网站服务器之间传递信息的，是一个基于请求与响应，无状态的，应用层的协议，是TCP&#x2F;IP协议传输数据，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作无连接：每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。SSL：网景公司设计了SSL（SecureSocketsLayer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 HTTPS和HTTP的区别主要如下：123451、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl（安全套接字层SSL）加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。5、https相对于http协议的连接方式来讲，性能方面会有所损耗。 HTTPS的工作流程123456第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。第五步：Web服务器利用自己的私钥解密出会话密钥。第六步：Web服务器利用会话密钥加密与客户端之间的通信。 HTTPS的优缺点12345678910111213141516171819优点： 1.SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 2.安全性： （1）、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议， 要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 缺点： 1.SEO方面： （1）使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电 （2）HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。 （3）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 （4）成本增加。 2.经济方面： (1)SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 (2)HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采 (3)HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响 免费HTTPS证书推荐(排名不分先后)12345678SSL 证书级别分为三种类型，域名型SSL证书（DV SSL）、企业型SSL证书（OVSSL）、增强型SSL证书（EVSSL）(1).Let's Encrypt (2).startSSL(3).Wosign沃通SSL(4).NameCheap (5).腾讯云DV SSL 证书(6).阿里云DV SSL证书(7).360网站卫士、百度云加速免费SSL、又拍云、七牛云","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"协议","slug":"协议","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"'结合百度ai实现自然语言分析'","slug":"结合百度AI实现自然语言分析","date":"2020-06-07T13:25:36.000Z","updated":"2020-06-20T10:28:58.828Z","comments":true,"path":"2020/06/07/结合百度AI实现自然语言分析/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/07/%E7%BB%93%E5%90%88%E7%99%BE%E5%BA%A6AI%E5%AE%9E%E7%8E%B0%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"百度AI开放平台地址：点击跳转官方文档地址：点击跳转","text":"百度AI开放平台地址：点击跳转官方文档地址：点击跳转 获取应用1.进行注册登陆2.找到文字识别–&gt;应用列表3.创建应用4.获取AppID,API Key,Secret Key 安装百度AI模块 1pip install baidu-aip 对文本进行错误检查123456789101112131415from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#定义检查文本text = '学习python，学习人工只能'#进行检查res = client.ecnet(text)print(res)#&#123;'log_id': 9052624029983259239, 'item': &#123;'vec_fragment': [&#123;'ori_frag': '人工只能', 'begin_pos': 16, 'correct_frag': '人工智能', 'end_pos': 24&#125;], 'score': 0.590899, 'correct_query': '学习python，学习人工智能'&#125;, 'text': '学习python，学习人工只能'&#125; 对文本进行标签处理12345678910111213141516from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#标签title = 'python人工智能在线学习'content = '我再北京学习人工智能，他是基于python的一门学科'#调取标签res = client.keyword(title,content)print(res)#&#123;'log_id': 2174377746871861863, 'items': [&#123;'score': 0.9486, 'tag': '人工智能'&#125;, &#123;'score': 0.768706, 'tag': 'python'&#125;]&#125; 对文本进行情感分析12345678910111213from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#情感分析text = '华为是一家很棒的公司'print(client.commentTag(text))#&#123;'log_id': 1058331879559622439, 'items': [&#123;'sentiment': 2, 'abstract': '华为是一家很棒的公司&lt;span&gt;&lt;/span&gt;', 'prop': '感觉', 'begin_pos': 20, 'end_pos': 20, 'adj': '棒'&#125;]&#125;","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"}]},{"title":"'第三方登录-gitee登录'","slug":"第三方登录-gitee登录","date":"2020-06-06T08:00:02.000Z","updated":"2020-06-20T10:12:40.142Z","comments":true,"path":"2020/06/06/第三方登录-gitee登录/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/06/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-gitee%E7%99%BB%E5%BD%95/","excerpt":"创建gitee应用1.登陆gitee","text":"创建gitee应用1.登陆gitee gitee登录网站2.点击头像,设置,第三方应用3.创建应用4.自定义应用名称，应用描述，应用回调网址等。5.创建完成，获取Client ID,Client Secret,还有应用回调地址。 gitee开发文档开发文档地址：点击跳转 代码实例12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;img :src=\"'http://localhost:8000/static/mayun.png'\" alt=\"\" @click=\"gitee_login\" &gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, methods:&#123; //第三方登录--&gt;gitee登录 gitee_login()&#123; var client_id = '8778f21baf13e5a37d2d5d74b66dc74b2716d4f44d18bed2f08f02c229142812' var back = 'http://localhost:8000/gitee_back' var url = 'https://gitee.com/oauth/authorize?client_id='+client_id+'&amp;redirect_uri='+back+'&amp;response_type=code' window.location.href = url &#125;, &#125; &#125; 6.获取code来换取access_token 12345678910111213141516171819#gitee三方登录url: path('gitee_back',Gitee_Back.as_view()), #gitee回调class Gitee_Back(APIView): def get(self,request): code = request.GET.get('code') print(code) redirect_uri = 'http://localhost:8000/gitee_back' # url = 'https://gitee.com/oauth/authorize?client_id='+ CLIENT_ID +'&amp;redirect_uri=' + redirect_uri +'&amp;response_type=code' data = &#123; 'client_id':CLIENT_ID, 'client_secret':CLIENT_SECRET, 'redirect_uri':redirect_uri, 'code':code, 'grant_type': 'authorization_code' &#125; url = 'https://gitee.com/oauth/token?grant_type=authorization_code&amp;code='+code+'&amp;client_id='+ CLIENT_ID +'&amp;redirect_uri='+ redirect_uri +'&amp;client_secret='+CLIENT_SECRET res = requests.post(url=url,data=data) print(res.json()) 7.点击开发文档，API文档，用户账户，获取授权用户资料，申请授权 12345678910111213141516171819# 接上access_token = res.json()['access_token']#获取tokentoken_uri = 'https://gitee.com/api/v5/user?access_token=' +access_tokenres = requests.get(url=token_uri)print(res.json())user_id = ''username = str(res.json()['name'])user = User.objects.filter(username=username).first()if user: #表示曾经登陆过 user_id= int(res.json()['id']) user.username = username print('已经登录过,id是%s,名字是%s'%(user.id,user.username))else: user = User(username=username,id=int(res.json()['id']),password=make_password(\"\")) user.save() user_id = user.id print('第一次注册，id是%s,名字是%s'%(user.id,user.username))return redirect('http://localhost:8080/?user_id='+str(user_id)+'&amp;username='+username)","categories":[{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/categories/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"}]},{"title":"'VOLANTIS博客的搭建'","slug":"VOLANTIS博客的搭建","date":"2020-06-05T07:30:08.000Z","updated":"2020-06-20T10:14:05.420Z","comments":true,"path":"2020/06/05/VOLANTIS博客的搭建/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/05/VOLANTIS%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置","text":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置 配置博客主题为VOLANTIS123#在站点配置_config.yml中修改blog/_config.ymltheme: volantis 配置博客主题标题123#在站点配置_config.yml中修改blog/_config.ymltitle: 你博客主题名称 front-matter12345678---cover: true/false #设置封面------ #参考资料references: - name: Apple Developer Documentation url: https://developer.apple.com/documentation/---","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/tags/hexo/"}]},{"title":"'jieba库的安装使用'","slug":"jieba库的安装使用","date":"2020-06-04T03:00:26.000Z","updated":"2020-06-20T10:15:49.188Z","comments":true,"path":"2020/06/04/jieba库的安装使用/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/04/jieba%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"jieba库的安装 1pip install jieba","text":"jieba库的安装 1pip install jieba jieba库的使用12345678910111213141516171819202122232425262728293031323334import jieba.analysedata = \"Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。\" \\ \"Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。\"#提取标签for keyword,weight in jieba.analyse.extract_tags(data,withWeight=True): print('%s:%s' % (keyword,weight))#输出内容# Building prefix dict from the default dictionary ...# Loading model from cache C:\\Users\\10186\\AppData\\Local\\Temp\\jieba.cache# Loading model cost 0.878 seconds.# Prefix dict has been built successfully.# Python:1.1385492859904762# 数据类型:0.585297130452381# Guido:0.5692746429952381# van:0.5692746429952381# Rossum:0.5692746429952381# 1989:0.5692746429952381# 1991:0.5692746429952381# 发行版:0.5270221099# 面向对象:0.5067895768571429# 程序设计:0.44264321266619044# 发明:0.31970364912190474# 动态:0.3195238865542857# 高级:0.3114256070914286# 语言:0.29349988448285713# 第一个:0.28425680430714284# 解释:0.2720391527752381# 年底:0.2701318006847619# 公开:0.26735277138999997# 发行:0.22793990734714284# 一种:0.19674458076142856","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"}]},{"title":"'无限极分类'","slug":"无限极分类","date":"2020-06-03T12:19:22.000Z","updated":"2020-06-20T10:29:54.488Z","comments":true,"path":"2020/06/03/无限极分类/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/03/%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/","excerpt":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样.","text":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样. 无限极分类 12345678910衣服 上衣 短袖 卫衣 裤子 牛仔裤 休闲裤 鞋子 运动鞋 休闲鞋 无限极分类应用场景很广泛，例： 帖子的回复功能 课程的目录章节 基于python,结合django+vue实现无限极分类(递归层级结构)在myapp中model.py文件下 123456789class Cate(models.Model): #id是主键，自增 #分类名称 name = models.CharField(max_length=200,null=True) #父级分类id pid = models.IntegerField() class Meta: db_table = 'cate' 数据库配置数据 使用drf框架进行序列化 123456789#导包from rest_framework import serializersfrom .models import Cate#序列化类class CateSer(serializers.ModelSerializer): class Meta: model = Cate fields = '__all__' 写一个用来进行递归的方法，进行层级结构划分 12345678910111213141516def Xtree(datas): lists = [] tree = &#123;&#125; for item in datas: tree[item['id']] = item print(tree[item['id']]) for i in datas: if not i['pid']: root = tree[i['id']] lists.append(root) else: parent_id = i['pid'] if 'child' not in tree[parent_id]: tree[parent_id]['child'] = [] tree[parent_id]['child'].append(tree[i['id']]) return lists 写视图接口并分配路由 123456789101112from .myser import CateSerfrom .cengji import Xtree# 递归层级分类class MyTree(APIView): def get(self,request): cates = Cate.objects.all() ser = CateSer(cates,many=True) trees = Xtree(ser.data) return Response(trees)#分配url# path('tree/',MyTree.as_view()), 测试接口 前端使用递归组件渲染所谓递归组件: 就是组件可以在它们自己的模板中调用自身，不过它们只能通过 name 选项来做这件事，例如给组件设置属性 name: ‘Reply’，然后在模板中就可以使用 Reply 调用自己进行递归调用了 设置Reply.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;li&gt; &lt;div :class=\"[data.id==0 ? 'root':'','reply']\"&gt; &#123;&#123;data.name&#125;&#125; &lt;/div&gt; &lt;ul v-if=\"data.child &amp;&amp; data.child.length&gt;0\"&gt; &lt;Reply v-for=\"c in data.child\" :key=\"c.id\" :data=\"c\"&gt;&lt;/Reply&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:\"Reply\",//递归需要设置name属性，才能在模板中调用自身 data()&#123; return&#123; &#125; &#125;, props:['data'], mounted() &#123; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.reply&#123; padding-left: 4px; border-left: 1px solid #eee;&#125;ul&#123; padding-left: 20px; list-style: none;&#125;.root&#123; display: none;&#125;&lt;/style&gt; 在其他组件调用Reply.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- import cengji from '@/components/cengji'&#123; path:'/cengji', name:'cengji', component:cengji&#125;, --&gt;&lt;template&gt; &lt;div&gt; &lt;Reply :data=\"data\"&gt;&lt;/Reply&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// import &#123;config,formatXml&#125; from '../config'// import mh_test from './mh_test.vue'import Reply from './Reply'// import md5 from 'js-md5'export default &#123; data()&#123; return&#123; data:&#123;&#125;, online:0, &#125; &#125;, components:&#123; Reply &#125;, mounted() &#123; this.get_token() &#125;, methods: &#123; get_token()&#123; this.axios(&#123; url:\"http://localhost:8000/tree/\", method:\"GET\" &#125;).then(resp=&gt;&#123; console.log(resp) var tree = &#123;'id':0,name:\"123\"&#125; tree['child'] = resp.data this.data = tree console.log(this.data) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.on &#123; background: #cdcbff;&#125;.off &#123;background: #fefdff;&#125;&lt;/style&gt; 前端结果展示","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"}]},{"title":"'算法-斐波那契数列'","slug":"算法-斐波那契数列","date":"2020-06-03T07:39:35.000Z","updated":"2020-06-20T10:26:08.190Z","comments":true,"path":"2020/06/03/算法-斐波那契数列/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/03/%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）","text":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 递归斐波那契数列(写法最简洁，但是效率最低，会出现大量的重复计算，时间复杂度O（1.618^n）,而且最深度1000) 12345678910def fib_func(n): # 定义出口 if n &lt;= 1: return 1 return func(n-1)+func(n-2) #第一位数和第二位数相加的结果for i in range(10): print(fib_func(i),end=\" \")#1 1 2 3 5 8 13 21 34 55 生成器斐波那契数列带有yield的函数都被看成生成器，生成器是可迭代对象，且具备iter 和 next方法， 可以遍历获取元素python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现iter方法，而iter方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的iter方法返回自身即可 1234567891011def fib_func(max): n,a,b = 0,0,1 while n &lt; max: yield b a,b = b,a+b n += 1fib_list = fib_func(10)for i in fib_list: #使用for循环遍历 print(i,end=\" \")#1 1 2 3 5 8 13 21 34 55","categories":[{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'python算法'","slug":"python算法","date":"2020-06-03T07:22:27.000Z","updated":"2020-06-24T03:29:48.890Z","comments":true,"path":"2020/06/03/python算法/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/03/python%E7%AE%97%E6%B3%95/","excerpt":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。","text":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。 常用排序算法： 1234567冒泡排序(*****)选择排序(*****)插入排序快速排序希尔排序归并排序堆排序 搜索是在一个项目集合中找到一个特定项目的算法过程。 常用搜索算法： 1234顺序查找二分法查找（*****）二叉树查找哈希查找 快速排序快速排序(quick sort)的采用了分治的策略。分治策略：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 12345678910111213141516171819202122232425262728#快速排序def quick_func(list): #判断列表长度是一位的话，直接返回，不需要排序 if len(list) &lt; 2: return list #基准值，也就是随机变量， 从列表中随机选取一个元素 tmp = list[0] left = [x for x in list[1:] if x &lt;= tmp]#小于等于基准值的元素组成的数组 print(left) right = [x for x in list[1:] if x &gt; tmp]#大于基准值的元素组成的数组 # print(right) return quick_func(left) + [tmp] + quick_func(right) #调用本身，递归li = [2,4,6,3,8,1,5]print(quick_func(li))#参考结果： # 随机 2 #第一次取出基准值 # 左 [1] # 右 [4, 6, 3, 8, 5] # 随机 4 #第二次取出基准值 # 左 [3] # 右 [6, 8, 5] # 随机 6 #第三次取出基准值 # 左 [5] # 右 [8] # [1, 2, 3, 4, 5, 6, 8] 冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。冒泡排序就是遍历数据，每次只与下一个数字比较，如果这两个数顺序不对，则与交换过来。就上面那个问题来说，因为要升序排列，所以数字越大越排在后面。则两个数比较的时候，如果后一个数比当前数小，则顺序不对，要将这两个数交换。 123456789101112#冒泡排序def bubble_sort(li): cli = len(li) for i in range(cli):#遍历所有数组 for j in range(cli-i-1):# if li[j] &gt; li[j+1]: #比较相邻两个元素，判断大小交换位置 li[j],li[j+1]=li[j+1],li[j]li = [1,5,2,6,3,7,4,8,9,0]bubble_sort(li)print(li) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","categories":[{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'redis命令即使用'","slug":"redis","date":"2020-06-03T01:39:25.000Z","updated":"2020-06-20T10:14:33.168Z","comments":true,"path":"2020/06/03/redis/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/03/redis/","excerpt":"Redis的安装","text":"Redis的安装 Reids官网：https://redis.io/ 1234567#Redis的安装： 1).下载地址：可以在官网下载最新版本 2).在该文件夹下输入cmd,进入黑窗口：'redis-server ./redis.windows.conf',可以看到运行效果图。基于C/S架构 #如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略,是默认的。 3).运行：另启动一个cmd窗口，输入'redis-cli',当看到'127.0.0.1:6379'时，就可以启动成功了 #注意：原来的reids-server窗口不能关闭，不然就无法访问服务端了。 4).'127.0.0.1:6379':127.0.0.1是本机ip，6379是Reids的服务端口，输入ping命令，返回PONG，就证明成功了。 Redis的数据类型1234567#Redis的数据类型： Redis支持五种数据类型： string（字符串） #二进制安全，可以包含任何数据，最大存储512MB hash（哈希） #键值对集合，适用于存储对象。 list（列表） #简单的字符串列表，按照插入顺序排序， set（集合） #无序集合，时间复杂O(1),元素唯一，存在返回0 zset(sorted set：有序集合) #有序集合，不能重复，不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。 Redis的定义12#Redis的定义： redis是一个key-value存储系统。redis的操作都是原子性的，redis支持各种不同方式的排序，redis的数据都是缓存在内存中。redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis的优势12345678910111213141516#redis介绍： 1).redis是使用C语言开发，支持网络，可基于内存亦可持久化的日志型key-value数据库，为开发语言提供多种API 2).redis存储数据，可以将内存中的数据保存在磁盘中，重启可以再次加载。 3).redis分为几种类型 4).redis支持数据备份，master-slave模式的数据备份--&gt;master:主人，slave：奴隶--&gt;主从模式#Redis的优势： 1).性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 2).丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 3).原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 4).丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 #redis的应用场景： 1).用来做缓存 --- redis的所有数据是放在内存中（内存型的数据库） 2).可以应用在某些特定的场景，比如社交类应用 3).在一些大型的系统中，巧妙的实现一些特定的功能：购物车，session的共享 Redis的命令123451).启动redis服务器： redis-server2).连接redis服务器： redis-cli3).远程服务执行命令： redis-cli -h host -p port -a password#例：连接到主机为127.0.0.1,端口为6379,密码为123的redis服务上 redis-cli -h 127.0.0.1 -p 6379 -a '123'#中文乱码： redis-cli --raw Redis keys命令1234567891011121).set key value 添加key值 2).get key 获取key值3).del key key存在，删除key值4).dump key 序列化给定key，返回被序列化得值5).exists key 检查key是否存在6).expire key seconds(秒数) 给key设置过期时间，以秒计时7).keys */key 获取key名称8).persist key 取消key的过期时间，key将永久保持9).ttl key 以秒为单位，返回key的剩余过期时间10).randomkey 从数据库随机返回一个key11).rename key newkey 修改key名字12).type key 返回key所储存的值的类型 Redis string命令123456781).getrange key start end 返回key中value的值，从0开始2).getset key value 将oldvalue改为newvalue，返回oldvalue3).mget key1 key2 key3 获取多个key值4).strlen key 返回value的长度5).mst key1 value1 key2 value2 同时设置一个或多个key-value对6).append key value 将指定的 value 追加到该 key 原来值（value）的末尾。7).incr key 将key中储存的数字值+18).decr key 将key中储存的数字值-1 Redis hash命令123456789101112 (key=hash表，field=字段，value=值)Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象 1).hmset key filed1 value1 field2 value2 创建一个hash表key，指定字段和value 2).hdel key field1 field2 删除一个或多个hash表 3).hexists key field1 查看hash表中，指定field是否存在 4).hget key field 获取hash表指定字段得值 5).hgetall key 获取hash表所有字段和值 6).hkeys key 获取hash表中的字段 7).hlen key 获取hash表中字段的数量 8).hmget key field1 field2 获取hash表中给定字段的值 9).hset key field value 将hash表中字段得值设为value 10).hvals key 获取hash表中所有值 Redis list命令1234567891011Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 1).lpush key value1 value2 创建一个key列表，插入值 2).lrange key start end 查询key列表，从start到end之间的value 3).blpop key timeout 删除第一个元素， 4).brpop key timeout 删除最后一个元素 5).lindex key index 根据索引获取列表中的元素 6).llen key 获取列表长度 7).lpop key 删除并获取第一个元素 8).lpush key value1 value2 将一个或多个值插入列表头部 9).lpushx key value 将一个值插入到已存在的列表头部 10).rpop key 删除列表的最后一个元素，返回删除的元素 Redis set命令1234567891011Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 1).sadd key value1 value2 创建一个集合，添加一个或多个值 2).scard key 获取集合的值的数量 3).sinter key1 key2 返回给定集合的交集 4).sismember key value 判断value是否在集合key中 5).smembers key 返回集合中的所有value 6).smove key1 key2 value 将value从key1集合移动到key2集合 7).spop key count 随机删除key集合中的count个元素 8).srandmember key count 随机返回key集合中的count个元素 9).srem key value1 value2 删除集合中的value元素 Redis set命令12345678Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 1).zadd key(有序集合) 分数 value 创建一个集合，并给出分数 2).zadd key start end withscore(分数) 查询集合从start到end之间的value，带分数 3).zcard key 获取有序集合和数量 4).zcount key min max 计算在有序集合中指定区间分数的数量","categories":[{"name":"redis","slug":"redis","permalink":"https://wzh3683.github.io/hexo_blog/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://wzh3683.github.io/hexo_blog/tags/redis/"}]},{"title":"'递归算法'","slug":"递归算法","date":"2020-06-03T01:39:25.000Z","updated":"2020-06-20T10:25:54.143Z","comments":true,"path":"2020/06/03/递归算法/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/03/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","excerpt":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?…","text":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?… 什么是函数嵌套调用？什么是递归？123函数内部是可以调用其他函数的，这种调用就是函数的嵌套调用。递归就是&#39;函数在内部直接或间接调用自己本身&#39;。 使用递归的注意事项123451.必须有明确的退出条件2.每次进入更深一层递归时，问题规模比上次递归都有所减少3.递归到一定层次就会出现结果4.递归效率不高，递归层数过多会导致栈溢出(栈内存不够用)5.栈溢出默认是1000,但是当递归到998就已经报错了。 栈溢出错误：1栈溢出错误：RecursionError: maximum recursion depth exceeded in comparison 解决栈溢出的办法：123#修改递归深度的值import syssys.setrecursionlimit(2000) 关于栈溢出例子：12345678import syssys.setrecursionlimit(2000) #设置最大递归深度是2000def sum_digui_func(n): if n &lt;= 0: return 0 return n + sum_digui_func(n-1)#当我们运行到1997是，还是可以运行的。到1998就报错，所以可以认为比设置最大递归深度-3就是可以运行的。print(sum_digui_func(1997)) 说到递归就要说下逆向思维，在大部分情况下，人们所想的是都是片面，也就是有局限性。逆向思维就是突破这个局限性，从另一方面去想怎么解决这个事情。 逆向思维小故事 1234关于司马光砸缸： 讲述了司马光砸坏水缸，救出同伴的古诗。 在大部分情况下的人，当时所想的是如何让人脱离水，从而救出人。 我们通过逆向思维，想到也可以使水脱离人，从而脱救，于是把水缸砸坏，使水流光从而进行救助。 递归求和 1234567def sum_func(n): #设定出口，退出条件 if n &lt;= 0: return 0 #调用自身，每次和自身-1相加 return n + sum_func(n-1)print(sum_func(5)) 阶乘 1234567def ride_func(n): #设定出口，退出条件 if n &lt;= 1: return 1 #调用自身，每次和自身-1相乘 return n + ride_func(n-1)print(ride_func(5))","categories":[{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'设计模式之工厂模式'","slug":"设计模式之工厂模式","date":"2020-06-02T08:34:10.000Z","updated":"2020-06-20T10:27:37.652Z","comments":true,"path":"2020/06/02/设计模式之工厂模式/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。","text":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。 简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。简单工厂实例化的类具有相同的接口或者基类，在子类比较固定并不需要扩展时，可以使用简单工厂。如数据库生产工厂就是简单工厂的一个应用采用简单工厂的优点是可以使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性；缺点是可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂，不符合OCP（开闭原则）的原则。简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。 与django结合实现工厂模式 12345678910111213141516171819202122232425262728293031323334class WeiBo: def __repr__(self): return '使用微博进行第三方登录'class DingDing: def __repr__(self): return '使用钉钉进行第三方登录'class Gitee: def __repr__(self): return '使用马云进行第三方登录'#实例化类weibo = WeiBo()dingding = DingDing()gitee = Gitee()#简单工厂模式class Factory: #这里使用静态方法 @staticmethod def Login(name): if name == 'weibo': return WeiBo() elif name == 'dingding': return DingDing() elif name == 'gitee': return Gitee()factory = Factory.Login(\"weibo\")#当name==weibo，输出使用微博进行第三方登录#当name==dingding，输出使用使用钉钉进行第三方登录#当name==gitee，输出使用马云进行第三方登录print(factory)","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"}]},{"title":"'schedule的定时任务'","slug":"celery的定时任务","date":"2020-06-01T06:44:33.000Z","updated":"2020-06-20T10:30:08.193Z","comments":true,"path":"2020/06/01/celery的定时任务/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/01/celery%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"使用定时任务定时执行","text":"使用定时任务定时执行 启动定时任务命令 12在和manage.py文件同级目录下： celery -A mydjango beat -l info 注意： 1234启动定时任务需要启动三个服务1.django后台服务：python manage.py runserver2.selery后台服务：celery worker -A mydjango -l info -P eventlet3.定时任务服务：celery -A mydjango beat -l info 启动定时任务出现错误 12ERROR: Pidfile (celerybeat.pid) already exists.Seems we're already running? (pid: 29396) 这个错误就是说启动服务的文件夹里有启动文件celerybeat.pid了，把他删掉就可以了，记得再次重启 在settings中配置12345678910111213#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称,解析字符串寻找 'schedule':timedelta(seconds=7200) #定时时长 &#125;&#125; 结合Django使用一个小案例：每1分钟提交一次log文件12345678910111213141516171819202122232425262728在settings配置#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称 'schedule':timedelta(seconds=60) #定时时长，,1分钟 &#125;&#125;创建一个task.py文件from celery.task import task#自定义异步任务@taskdef async_test(): print('异步任务') #文件名 filename = 'celeray.log' #追加形式写入 with open(filename,'a') as f: #写入文件时间 f.write(str(datetime.datetime.now())+'\\n') return '123123'","categories":[{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/categories/celery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/tags/celery/"}]},{"title":"'关于使用celery执行post请求出现启动服务错误的问题'","slug":"关于使用celery出现错误的问题","date":"2020-06-01T03:38:28.000Z","updated":"2020-06-20T10:27:48.362Z","comments":true,"path":"2020/06/01/关于使用celery出现错误的问题/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/01/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8celery%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"启动celery命令 1celery worker -A celery_task -l info -P eventlet","text":"启动celery命令 1celery worker -A celery_task -l info -P eventlet 在django中使用restful风格做开发时，发现都不能发送在使用post方法的时候，因为我的celery后台一直是启动的，所以不运行task中封装的函数，然后一直在找解决办法，于是我重启celery后台，会出现一个错误 该错误描述： 1TypeError: wrap_socket() got an unexpected keyword argument '_context' 于是找了解决办法，换个启动命令request包的request.post发送后，传不回数据 所以，在改变服务器启动方法不要用eventlet，加个参数 1celery worker -A mydjango -l info -P=solo","categories":[{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/categories/celery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/tags/celery/"}]},{"title":"'celery异步的使用'","slug":"celery异步的使用","date":"2020-06-01T01:23:44.000Z","updated":"2020-06-20T10:30:15.385Z","comments":true,"path":"2020/06/01/celery异步的使用/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/06/01/celery%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2","text":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2 django配置celery在settings中配置123456#代理url，异步任务代理CELERY_BROKER_URL = 'redis://localhost:6379/'#保存结果CELERY_RESULT_BACKEND = 'redis://localhost:6379/'#保存类型格式，使用jsonCELERY_RESULT_SERIALIZER = 'json' 在和settings同一级目录下，创建celery.py文件，进行配置文件，用来启动服务123456789101112131415# -*- coding: utf-8 -*-from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery# 设置环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mydjango.settings')# 注册Celery的APPapp = Celery('mydjango')# 绑定配置文件,声明命名空间,可以在电脑任何位置启动app.config_from_object('django.conf:settings', namespace='CELERY')# 自动发现各个app下的tasks.py文件app.autodiscover_tasks() 在和settings同一级目录下的init.py文件下，当启动服务，加载init.py文件配置12345678910from __future__ import absolute_import, unicode_literalsfrom .celery import app as celery_app#导包import pymysql#初始化pymysql.install_as_MySQLdb()#加载celery应用__all__ = ['celery_app'] 在myapp文件夹下，创建一个tasks.py文件，自定义任务123456789from celery.task import task#自定义异步任务#实用装饰器声明是异步任务@taskdef async_test(): print('异步任务') return '123123' 触发异步任务队列1234567#调用tasks异步from myapp import tasks#触发异步任务视图def celery_test(request): #使用delay()异步任务调用 res = tasks.async_test.delay() return JsonResponse(&#123;'task_id':res.task_id&#125;) 配置url12345from myapp.views import celery_testurlpatterns = [ #定义超链接路由 path('celery_test/',celery_test),] 启动celery服务1231.先启动django服务：python manage.py runserver2.在manage.py文件的同级目录下，启动celery服务3.以协程方式启动服务命令：celery worker -A mydjango -l info -P eventlet 实例:做邮件发送使用celery123456789101112131415161718192021222324252627282930313233343536373839404142#task中：from celery.task import taskfrom mydjango.settings import MY_MAIL,MY_PASSfrom email.mime.text import MIMETextfrom email.utils import formataddrimport smtplib@taskdef mail(subject,content,mailaddr): #声明邮件对象 msg = MIMEText(content,'plain','utf-8') #设置发送方对象 msg['From'] = formataddr(['在线教育平台',MY_MAIL]) #设置收件方对象 msg['To'] = formataddr(['尊敬的客户',mailaddr]) #设置标题 msg['Subject'] = subject #设置smtp服务器 server = smtplib.SMTP_SSL('smtp.qq.com',465) #登录邮箱 server.login(MY_MAIL,MY_PASS) #发送邮件 server.sendmail(MY_MAIL,[mailaddr],msg.as_string()) #关闭smtp连接，节约系统资源 server.quit()#退出#在视图中class Register(APIView): def post(self,request): email = request.data.get('email') #获取前端用户邮件 subject = '亲爱的用户您好：,欢迎注册在线教育平台' #邮件标题 yanzhengma = random.randint(1000,9999) print(yanzhengma) #数字验证码 r.set('email',yanzhengma,120) #存到redis print(123,r.get('email')) content = '欢迎注册在线教育平台，您的验证码是%s，请在2分钟内输入，失效请重新获取' % yanzhengma print(content) #邮件内容 mailaddr = email #给发送邮件 #参数需要存放到delay(里) send_email = tasks.mail.delay(subject, content, mailaddr) #异步发送邮件调用邮件 #使用celery需要使用JsonResponse返回 return JsonResponse(&#123;'code':200,'yzm':yanzhengma,'send_email':send_email.task_id&#125;)","categories":[{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/categories/celery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/tags/celery/"}]},{"title":"git","slug":"git","date":"2020-05-31T05:10:10.000Z","updated":"2020-06-20T10:16:11.618Z","comments":true,"path":"2020/05/31/git/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/05/31/git/","excerpt":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。","text":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。 Git的下载与安装1git的下载与安装:https:&#x2F;&#x2F;blog.csdn.net&#x2F;Dan_Xiao_Hui&#x2F;article&#x2F;details&#x2F;105637182 在Gitee上创建仓库12345678910111213141516171819202122232425在Gitee上创建仓库： 1.点击+号，新建仓库，如图1, 2.编辑仓库名，仓库路径，仓库描述，公开 3.点击创建创建git仓库： 1.创建一个文件夹cangku:mkdir cangku 2.进入文件夹：cd cangku 3.初始化git：git init 4.将要上传的文件添加到暂存区：git add -A 5.将暂存区文件提交到仓库：git commit -m &#39;描述&#39; 6.因为是第一次上传，所以需要确定好gitee的git仓库： git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;wang_zeng_hui&#x2F;cangku.git #####只有第一次上传，需要确定Git仓库位置，以后不需要 7.推送到云端：git push -u origin master需要用户名或密码：(只需要写入一次)(图4) git config --global user.name &quot;你登录gitee的名字&quot; git config --global user.email &quot;你登录的email&quot;删除仓库： 1.进入管理(如图5) 2.点击删除仓库(如图6) 3.根据要求输入内容(如图7) 4.登录账号,进行验证(如图8) 图1 图2 图3 图4 删除仓库图5 图6 图7 图8 Git的命令1234567891011121314Git的常用命令： 1.将线上网址克隆到本地：git clone git网址 2.将工作区的修改添加到暂存区：git add -A 3.将暂存区的文件提交到仓库：git commit -m &#39;描述&#39; 4.将仓库推送到云端：git push origin master其他命令： 清掉配置：git config --system --unset credential.helper 保存密码：git config --global credential.helper store 查看版本日志：git log 简单日志：git log --pretty&#x3D;oneline 回退操作：git reset --hard &#39;版本号&#x2F;日志&#39; 回退之后返回之前操作日志：git reflog git reset --hard &#39;版本号&#x2F;日志&#39; Git的分支命令123456789101112131415在我们每次提交之后都会有记录，Git把它们穿成时间线，形成类似于时间轴的东西。这个时间轴就是一个分支，我们称之为master分支。分支相关命令： 查看分支：git branch 查看所有分支：git branch -a 查看远端分支：git branch -r 创建并切换分支：git checkout -b 分支名 建立本地与线上分支关联：git push --set-upstream origin 分支名(可以不切换分支就能提交) 创建分支：git branch 分支名 切换分支：git checkout 分支名 合并分支：git merge 被合并的分支名（需要先切换到master分支） 删除分支：git branch -d 分支名 删除远程分支：git push origin --delete 分支名 注意：当我们进行删除分支的时候，注意要先退出要删除的分支，不然会报错。 Git的合并1234561.创建dev分支：git checkout -b dev2.将本地分支提交线上：git push --set-upstream origin dev3.切换master分支：git checkout master4.合并分支：git merge dev(直接push提交，不需要推送)5.合并之后推送到线上：git push origin master","categories":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"}]},{"title":"'序列化类的使用'","slug":"day13-序列化类的使用","date":"2020-05-10T02:13:08.000Z","updated":"2020-06-20T10:30:35.713Z","comments":true,"path":"2020/05/10/day13-序列化类的使用/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/05/10/day13-%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"rest_framework的下载1pip install djangorestframework","text":"rest_framework的下载1pip install djangorestframework 在settings中注册rest_framework123456789101112INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'corsheaders', #后端跨域 'rest_framework', #rest_framework框架 'myapp', 'dwebsocket'] 在django的app中创建一个serializers.py文件12345678910111213#导包from rest_framework import serializers#导入需要序列化的表from myapp.models import *#建立序列化类class CarouselSer(serializers.ModelSerializer): #针对表进行序列化 class Meta: model = Carousel #表名 fields = '__all__' #所有字段 在views视图中123456789from myapp.myser import * #导入序列器class GetCarousel(APIView): def get(self,request): #读库 carousels = Carousel.objects.all() #序列化操作 carousels_ser = CarouselSer(carousels,many=True) return Response(carousels_ser.data) 使用序列化的增删改查操作12345678910111213141516171819202122232425262728293031323334353637383940#url： path('getcarousel/',GetCarousel.as_view()),class GetCarousel(APIView): #查询操作 def get(self,request): #读库 carousels = Carousel.objects.all() #序列化操作 carousels_ser = CarouselSer(carousels,many=True) return Response(&#123;'data':carousels_ser.data&#125;) #添加操作 def post(self,request): name = request.data.get('name',None) src = request.data.get('link',None) img = request.data.get('imgs',None) ser = Carousel.objects.filter(name=name).first() if ser: return Response(&#123;'msg':'幻灯片已存在'&#125;) carousel = Carousel(name=name,src=src,img=img) carousel.save() #保存入库 return Response(&#123;'code': 200, 'msg': '添加成功'&#125;) #删除操作 def delete(self,request): id = request.GET.get('id',None) Carousel.objects.filter(id=id).delete() return Response(&#123;'code': 200, 'msg': '删除成功'&#125;) #修改操作 def put(self,request): id = request.data.get('id',None) name = request.data.get('name',None) src = request.data.get('link',None) img = request.data.get('imgs',None) car = Carousel.objects.filter(id=id).first() car.name = name car.src = src car.img = img car.save() return Response(&#123;'code':200, 'msg': '修改成功'&#125;) 注意12345rest_framework自带增删改查四种方法查询：get：Carousel.objects.all() ---&gt;method:'GET'增加：post：carousel.save() ---&gt;method:'POST(data)',request.data.get()删除：delete：Carousel.objects.filter(id=id).delete() ---&gt;method:'DELETE(params)',request.GET.get()修改：put：carousel.save() ---&gt;method:'PUT(data)',request.data.get() vue代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;template&gt; &lt;div&gt; &lt;center&gt; &lt;table border=\"1\" style=\"text-align: center;\"&gt; &lt;tr&gt; &lt;td&gt; 名称 &lt;/td&gt; &lt;td&gt; 链接 &lt;/td&gt; &lt;td&gt; 图片 &lt;/td&gt; &lt;td&gt; 添加 &lt;/td&gt; &lt;td&gt; 修改 &lt;/td&gt; &lt;td&gt; 删除 &lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in lunbo_list\" :key=\"index\"&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &#123;&#123;item.name&#125;&#125; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;a :href=\"item.src\" target=\"_black\"&gt;&#123;&#123;item.src&#125;&#125;&lt;/a&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;img :src=\"item.img\" alt=\"\"&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"green\" @click=\"put_lunbo(item.id)\"&gt;修改&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"red\" @click=\"del_lunbo(item.id)\"&gt;删除&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; name：&lt;input type=\"text\" v-model=\"name\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; img：&lt;input type=\"text\" v-model=\"imgs\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; src：&lt;input type=\"text\" v-model=\"link\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;br&gt; &lt;tr&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"blue\" @click=\"add_lunbo\"&gt;添加&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/tr&gt; &lt;/table&gt; &lt;/table&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; name：&lt;input type=\"text\" v-model=\"name\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; img：&lt;input type=\"text\" v-model=\"imgs\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; src：&lt;input type=\"text\" v-model=\"link\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;br&gt; &lt;tr&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"blue\" @click=\"put_lunbo1\"&gt;修改&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/tr&gt; &lt;/table&gt; &lt;/center&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; lunbo_list:[], name:\"\", link:\"\", imgs:\"\", &#125; &#125;, mounted() &#123; this.lunbo(); &#125;, methods: &#123; lunbo()&#123; this.axios(&#123; url:'http://localhost:8000/getcarousel/', method:'GET', &#125;).then(resp=&gt;&#123; console.log(resp) this.lunbo_list = resp.data.data &#125;) &#125;, //增加 add_lunbo()&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'POST', data:&#123; name:this.name, link:this.link, imgs:this.imgs, &#125; &#125;).then(resp=&gt;&#123; console.log(resp) this.$router.go(0) &#125;) &#125;, //删除 del_lunbo(id)&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'DELETE', params:&#123; id:id &#125; &#125;).then(resp=&gt;&#123; console.log(resp) alert(resp.data.msg) this.$router.go(0) &#125;) &#125;, //修改跳转 put_lunbo(id)&#123; //网页跳转传递id this.$router.push(&#123;'path':'/my_lunbo',query:&#123;'aid':id&#125;&#125;) &#125;, //修改 put_lunbo1()&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'PUT',//指定修改方法 data:&#123; id:this.$route.query.aid, name:this.name, link:this.link, imgs:this.imgs, &#125; &#125;).then(resp=&gt;&#123; console.log(resp) alert(resp.data.msg) this.$router.go(0) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;img&#123; width: 100px; height: 100px;&#125;&lt;/style&gt;","categories":[{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/categories/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"}]},{"title":"'Django中间件'","slug":"day13-django中间件","date":"2020-05-07T18:46:11.000Z","updated":"2020-06-20T10:30:40.980Z","comments":true,"path":"2020/05/08/day13-django中间件/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/05/08/day13-django%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"django的生命周期流程图中间件位于web服务端与url路由层之间 中间件的响应流程：当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。","text":"django的生命周期流程图中间件位于web服务端与url路由层之间 中间件的响应流程：当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。 中间件的五个方法1234567891011121314151617181920212223# 导包from django.utils.deprecation import MiddlewareMixin #中间件class My_MiddlewareMixin(MiddlewareMixin): # 请求之前 def process_request(self, request): pass # 视图渲染之前 def process_view(self, request, view_func, view_args, view_kwargs): pass # 该方法对视图函数返回值有要求，必须是一个含有render方法类的对象，才会执行此方法 def process_template_response(self, request, response): pass def process_exception(self, request, exception): pass # 返回之前 def process_response(self, request, response): # 注意：response需要使用return返回，不然报错 return response process_view的参数12345678# 该方法有四个参数# request是HttpRequest对象。# view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）# view_args是将传递给视图的位置参数的列表（无名分组分过来的值）.# view_kwargs是将传递给视图的关键字参数的字典（有名分组分过来的值）。 view_args和view_kwargs都不包含第一个视图参数（request）。# Django会在调用视图函数之前调用process_view方法。def process_view(self, request, view_func, view_args, view_kwargs): pass process_response错误：123456 if response.get('X-Frame-Options') is not None:AttributeError: 'NoneType' object has no attribute 'get'# 原因：就是没有返回response# 解决def process_response(self, request, response): return response 定义中间件之后在settings中注册中间件12345678910111213MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', #这里是新增的中间件 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', #加载自定义中间件 文件夹名.文件名.类名 # 'myapp.views.MyMiddleware', 'myapp.md_user.My_MiddlewareMixin',] 使用django原生Httpresponse返回Json格式123456789def process_request(self, request): # 第一种： # content_type=\"application/json\"声明json类型 # indent=4四个空格，美观 # ensure_ascii=False不使用ascii编码，输出中文 return Httpresponse(json.dumps(&#123;'message':'您的秘钥无权限'&#125;,indent=4,ensure_ascii=False),content_type=\"application/json\") # 第二种： # json_dumps_params=dict return JsonResponse(&#123;'message':'您的秘钥无权限'&#125;,safe=False,json_dumps_params=(&#123;'ensure_ascii':False,'indent':4&#125;)) 因为每次请求都要走中间件，所以针对路由判断是否走中间件1234def process_request(self, request): # 获取路由 if request.path_info.startswith('/userinfo/'): return Httpresponse(json.dumps(&#123;'message':'您的秘钥无权限'&#125;,indent=4,ensure_ascii=False),content_type=\"application/json\")","categories":[{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/categories/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"}]},{"title":"'第三方登录-钉钉登录'","slug":"day08-第三方登录-钉钉登录","date":"2020-04-28T05:10:38.000Z","updated":"2020-06-20T10:27:17.964Z","comments":true,"path":"2020/04/28/day08-第三方登录-钉钉登录/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/04/28/day08-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-%E9%92%89%E9%92%89%E7%99%BB%E5%BD%95/","excerpt":"钉钉企业注册：点击跳转 官方文档：点击跳转 悦哥钉钉登录博客：点击查看","text":"钉钉企业注册：点击跳转 官方文档：点击跳转 悦哥钉钉登录博客：点击查看 钉钉登录1.注册钉钉企业 2.登录企业后台管理 3.选择应用开发 4.移动接入应用-&gt;登录 5.创建扫码登录应用授权 6.获取创建以后企业应用的appid,appsecret,回调域名 代码示例12345678910urls：path('ding_url/',ding_login),#登录顶顶def ding_login(request): #钉钉应用的appid appid = 'dingoab7edavvvtdcwqcra' # 钉钉应用的回调地址 redirect_uri = 'http://127.0.0.1:8000/callback/' #重定向到 return redirect('https://oapi.dingtalk.com/connect/qrconnect?appid=' +appid+'&amp;response_type=code&amp;scope=snsapi_login&amp;state=STATE&amp;redirect_uri='+redirect_uri) 7.钉钉会将code返回到回调网址中因为钉钉只有java和php的sdk,所以使用hmac加密自己写sdk 123456789101112131415161718192021222324252627282930313233343536373839urls：path('callback/',ding_back),#构造钉钉对调方法。def ding_back(request): #获取code code = request.GET.get('code',None) print('code是：%s'%code) #构造时间戳 t = time.time() timestamp = str(int(round(t*1000))) print('时间：',timestamp) #URL签名参数说明 #钉钉的appSecret appSecret = '8F3q2UmU-2ljILNJAtodsnFaLllpMEioNWI5GRtnoz5OyubMYbiTxlVC3yrPmHiE' #构造签名 signature = base64.b64encode(hmac.new(appSecret.encode('utf-8'),timestamp.encode('utf-8'),digestmod=sha256).digest()) #请求接口，换取用户名 payload = &#123;'tmp_auth_code':code&#125; headers = &#123;'Content-Type':'application/json'&#125; res = requests.post('https://oapi.dingtalk.com/sns/getuserinfo_bycode?' 'accessKey=dingoab7edavvvtdcwqcra&amp;timestamp='+timestamp+ '&amp;signature='+urllib.parse.quote(signature.decode('utf-8')),headers=headers,data=json.dumps(payload)) res_dict = json.loads(res.text) print(res_dict) username = str(res_dict['user_info']['nick']) user = User.objects.filter(username=username).first() if user: #数据库有该用户名，直接登录 user.username = username print('已经登陆过，用户名',username) else: #没有登录,注册 user = User(username=username) user.save() print('首次注册，用户名',username) return redirect('http://localhost:8080/?username='+username) # return HttpResponse(res.text)","categories":[{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/categories/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"}]},{"title":"第三方登录-微博登录","slug":"day08-第三方登录-微博登录","date":"2020-04-28T03:24:55.000Z","updated":"2020-06-20T10:27:21.894Z","comments":true,"path":"2020/04/28/day08-第三方登录-微博登录/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/04/28/day08-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-%E5%BE%AE%E5%8D%9A%E7%99%BB%E5%BD%95/","excerpt":"微博登录思维导图","text":"微博登录思维导图 在微博创建应用1.第一步2.第二步3.第三步4.第四步5.第五步6.第六步 代码示例vue代码 123456789101112131415161718192021222324252627282930&lt;template&gt;&lt;div&gt;&lt;img :src=\"wb_src\" alt=\"点击跳转微博第三方登录\" @click=\"sina\" class=\"imgcode\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; //微博登录url //图片路径 wb_src:'http://127.0.0.1:8000/static/sina.png', &#125; &#125;, methods:&#123; //微博第三方登录 sina()&#123; //拼接url //App Key let client_id = 2731357014; //授权回调页 let redirect_uri = 'http://127.0.0.1:8000/md_admin/weibo'; // //请求url let url = 'https://api.weibo.com/oauth2/authorize?client_id='+client_id+'&amp;redirect_uri='+redirect_uri; // //跳转微博登录页,//返回code，然后后端去接收 window.location.href = url &#125; &#125; &#125; django代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950urls路径配置：path('md_admin/weibo/',wb_back),#新浪微博回调方法def wb_back(request): #接受参数 code = request.GET.get('code',None) print('code是%s'%code) #定义token的获取地址 url = 'https://api.weibo.com/oauth2/access_token' #定义参数 data = &#123; 'client_id':'2731357014',#App Key 'client_secret':'3eb11995fdd72c3b33b3971caac21ffe',#App Secret 'grant_type':'authorization_code',#类型 'code':code,#获取到的code 'redirect_uri':'http://127.0.0.1:8000/md_admin/weibo' &#125; re = requests.post(url=url,data=data) print('re的json是：',re.json()) #换取新浪微博用户昵称 weibo_url = 'https://api.weibo.com/2/users/show.json' params = &#123; 'access_token':re.json()['access_token'], 'uid':re.json()['uid'] &#125; res = requests.get(url=weibo_url,params=params) print('res的json是：',res.json()) print(res.json()) #定义新浪id和用户id sina_id = '' user_id = '' #判断是否使用新浪微博登陆过 user = User.objects.filter(username=str(res.json()['name'])).first() if user: #代表该账号曾经登陆过 sina_id = user.username user_id = user.id else: #首次登录,入库 user = User(username=str(res.json()['name']),password=\"\") user.save() user = User.objects.filter(username=str(res.json()['name'])).first() sina_id = user.username user_id = user.id print('用户是：',sina_id,user_id) #重定向到首页 return redirect('http://127.0.0.1:8080?sina_id='+str(sina_id)+'&amp;user_id='+str(user_id)) # return HttpResponse('回调成功') 关于错误123今日写微博登录犯了一个很典型的错误: 就是单词打错：所有的client都拼写成了clinet 因为是在访问url，所以报了一个'请求不合法错误'","categories":[{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/categories/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"}]},{"title":"'项目目录'","slug":"day02项目目录","date":"2020-04-20T23:55:29.000Z","updated":"2020-06-20T10:18:10.174Z","comments":true,"path":"2020/04/21/day02项目目录/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/04/21/day02%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/","excerpt":"vue有关项目目录","text":"vue有关项目目录 vue的项目目录1234567891011121314151617181920212223build:打包文件config:配置文件 dev.env.js:开发环境变量 index.js:生产环境变量 prod.env.js:灰度环境dist:打包之后存放的文件node_modules:安装的依赖，配置文件,基于package.json下载(该文件不能提交到仓库,需要加入.gitignore).gitignore:存放不需要上传仓库的文件package.json:读取存放依赖，配置等信息 heyui:网页样式 js-mds:加密 style-loader:样式 vue:vue本体 vue-drag-verify:验证码 vue-router:路由components:组件文件夹router&#x2F;index.js:路由 path：路径url name：命名空间 components:导包组件 mode：&#39;history&#39; 取消hash风格的#App.vue：渲染组件main.js：入口文件，vue的组件，实例等都存在这里 hugo的项目目录123456789101112131415161718archetypes:文本配置文件content:生成的md文档data:数据文件夹layouts:布局public:打包文件resources:资源static:静态文件thems:主题config.homl:网站配置文件 baseURL:线上&#x2F;线下url languageCode:语言 title:标题 theme:主题 params：简介和描述 description:简介 themColor:博客主题颜色修改主题颜色：在themes--&gt;hyde--&gt;static--&gt;css--&gt;hyde.css中改颜色(可以自定义主题和颜色)","categories":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"}]},{"title":"Vue启动和命令","slug":"day02vue启动和命令","date":"2020-04-20T23:03:21.000Z","updated":"2020-06-20T10:17:35.572Z","comments":true,"path":"2020/04/21/day02vue启动和命令/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/04/21/day02vue%E5%90%AF%E5%8A%A8%E5%92%8C%E5%91%BD%E4%BB%A4/","excerpt":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0)","text":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0) 三大框架(三大框架都是基于node)1234567891011React： 1 自组件重复渲染问题需要手动优化 2 可以使用redux进行状态管理，函数式，不可变，模式化，时间旅行 3 可使用JSX，完全的javascript能力 4更繁荣的社区生态Vue： 1 可使用JSX，但推荐使用模版语言而不是JSX 2 学习曲线平缓Angular： 1 完善的MV框架，包含模版，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能 2 typescript 3 脏检查，对脏数据的检查，比较UI和后台的数据是否一致 安装依赖(npm)12345678910111213npm： 1.npm官网：https:&#x2F;&#x2F;www.npmjs.com&#x2F; 2.下载安装npm 3.给npm配置环境变量检查npm： 命令：npm -v (6.14.4)关于npm命令： 1.npm默认源是github，因为是外网，所以我们要改源（淘宝源）。命令： npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org 2.查看npm配置：npm config list 3.当npm版本过低，更新版本：npm install -g npm vue1234567891011121314151617181920vue的中文文档：https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html关于vue命令： 1.清空本地缓存：npm cache clean --force 1.在vue中安装依赖&#x2F;配置文件：npm install 2.启动vue：npm run dev 退出：ctrl+cvue依赖： npm install axios --save npm install style-loader —-save npm install heyui --save npm install js-md5 --save关于vue服务启动失败： 1.关掉命令行，退到上一级目录，手动删除node_modules,然后npm install 2.下载rimarf命令：npm install rimraf -g 删除node_modules命令：rimraf node_modules (图2) #使用前提，npm需要是新版本 #优先使用第二个理由：第一个手动删除需要花费大量时间，删除进度缓慢","categories":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"}]},{"title":"环境变量的配置","slug":"day02环境变量","date":"2020-04-20T18:58:38.000Z","updated":"2020-06-20T10:18:32.156Z","comments":true,"path":"2020/04/21/day02环境变量/","link":"","permalink":"https://wzh3683.github.io/hexo_blog/2020/04/21/day02%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"环境变量的配置1.找到此电脑","text":"环境变量的配置1.找到此电脑 2.点击右键–&gt;属性 3.点击高级系统设置 4.点击环境变量 5.选择用户变量或者系统变量，点击path，点击编辑 6.点击新建，然后输入需要配置环境变量的路径，一般情况下在bin目录（或者在cmd下） 7.编辑好路径之后，点击确定，再点击确定。然后退出环境变量，确保更改成功。8.ok","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"}]}],"categories":[{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/categories/flask/"},{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/categories/python/"},{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E6%94%AF%E4%BB%98/"},{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/categories/celery/"},{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/categories/hexo/"},{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"},{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/categories/vue/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/categories/django/"},{"name":"redis","slug":"redis","permalink":"https://wzh3683.github.io/hexo_blog/categories/redis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wzh3683.github.io/hexo_blog/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://wzh3683.github.io/hexo_blog/tags/flask/"},{"name":"websocket","slug":"websocket","permalink":"https://wzh3683.github.io/hexo_blog/tags/websocket/"},{"name":"django","slug":"django","permalink":"https://wzh3683.github.io/hexo_blog/tags/django/"},{"name":"支付","slug":"支付","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E6%94%AF%E4%BB%98/"},{"name":"钉钉","slug":"钉钉","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E9%92%89%E9%92%89/"},{"name":"celery","slug":"celery","permalink":"https://wzh3683.github.io/hexo_blog/tags/celery/"},{"name":"hexo","slug":"hexo","permalink":"https://wzh3683.github.io/hexo_blog/tags/hexo/"},{"name":"vue","slug":"vue","permalink":"https://wzh3683.github.io/hexo_blog/tags/vue/"},{"name":"算法","slug":"算法","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"js","slug":"js","permalink":"https://wzh3683.github.io/hexo_blog/tags/js/"},{"name":"又拍云","slug":"又拍云","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"多线程","slug":"多线程","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"异步","slug":"异步","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%BC%82%E6%AD%A5/"},{"name":"协议","slug":"协议","permalink":"https://wzh3683.github.io/hexo_blog/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"redis","slug":"redis","permalink":"https://wzh3683.github.io/hexo_blog/tags/redis/"}]}