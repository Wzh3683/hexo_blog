{"meta":{"title":"WZH的博客","subtitle":"","description":"","author":"王增辉","url":"http://www.okwzh.cn","root":"/"},"pages":[{"title":"about","date":"2020-05-28T12:12:33.000Z","updated":"2020-06-12T10:20:52.137Z","comments":false,"path":"about/index.html","permalink":"http://www.okwzh.cn/about/index.html","excerpt":"","text":"————————————————————————————————————————————————————————————————————————————————————————————————— *基本信息王增辉 1998年4月 北京 Python全栈开发工程师 3年工作经验 手机：13383913683 邮箱：okwzh3683@gmail.com 个人网站：https://www.okwzh.cn—————————————————————————————————————————————————————————————————————————————————————————————————*个人简介三年Python全栈开发经验，掌握Django框架，作为主力工程师参与设计于开发过多个项目，负责系统核心模块的开发，测试与自动化部署，由高并发WEB应用框架经验。掌握爬虫技术，熟练使用Scrapy，熟悉前端业务规范，掌握vue.js开发，掌握websocket，掌握MySQL,redis，MongoDB数据库与LINux系统的常见机制与原理。由优秀的学习能力与团队沟通能力，经常与团队进行技术分享，能与团队共同成长。—————————————————————————————————————————————————————————————————————————————————————————————————*教育经历2012.08 - 2016.06 北京电子科技大学通信工程学院 统招一本—————————————————————————————————————————————————————————————————————————————————————————————————*技能列表● 后端框架：Django，Flask，Scrapy ● 前端：Vue.js,axios,jquery,node.js ● 前端框架：Vue.js，Node.js ● 数据库：MySQL , redis , MongoDB ● 工具：Git,Docker,Postman ● 编译器：PyCharm,Visual Studio Code,Sublime Text—————————————————————————————————————————————————————————————————————————————————————————————————*工作经历● 2017年9月 - 2019年5月 北京谐云科技有限公司—初级python开发工程师 ● 2019年7月 - 至今 北京微点网络科技有限公司—高级全栈开发工程师—————————————————————————————————————————————————————————————————————————————————————————————————*近期参与项目主导北京谐云科技跨境移动聚合支付平台开发● 搭建基于Docker挂载Nginx-rtmp的直播服务器 ● 使用FFmpeg利用客户端设备进行推流，对视频进行头图提取，精华片段转换动图，视频埋点，视频信息分析等操作 ● 开发，测试点播，直播，播单等7个模块 ● 采用FastDfs分布式文件系统作为海量视频存储方案，利用视频指纹规避重复文件问题,节约了大约20%的硬盘空间 ● 在网页端使用vue.js作为载体利用video.js作为直播流播放器，优化延迟达到500ms左右 ● 利用Nginx反向代理后台uwsgi+Django的点播接口，并且针对性使用Nginx负载均衡策略 ● 使用Bootstrap作为播放页响应式设计解决方案，一套代码自适应大小屏应用，降低了50%左右的移动端开发成本 ● 利用协同过滤算法针对用户和视频两个维度分别画像，定制视频精准推荐系统 主导北京谐云科技跨境移动聚合支付平台开发● 基于Django实现Restful风格的在线聚合支付接口，聚合封装了支付宝，微信，京东等三方支付平台 ● 使用Mysql存储数据，配置主从热备，使用Celery实现异步邮箱和短信推送 ● 利用Websocket实现后端消息主动推送，改造前端传统轮询技术框架，减少了30%的网络请求数，节约了大约一半的可用带宽 ● 使用Redis作为缓存介质，利用其分布式锁和队列的特性开发并测试抢单秒杀功能 ● 开发，测试登录/注册，订单，支付/退款等7个模块"},{"title":"所有分类","date":"2020-06-05T11:00:44.079Z","updated":"2020-06-05T11:00:44.079Z","comments":false,"path":"categories/index.html","permalink":"http://www.okwzh.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-05T11:35:31.222Z","updated":"2020-06-05T11:35:31.222Z","comments":true,"path":"comments/index.html","permalink":"http://www.okwzh.cn/comments/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-28T12:08:01.000Z","updated":"2020-05-28T12:11:47.932Z","comments":false,"path":"tags/index.html","permalink":"http://www.okwzh.cn/tags/index.html","excerpt":"","text":""},{"title":"秃顶程序员plus","date":"2020-06-12T10:44:36.507Z","updated":"2020-06-12T10:44:36.507Z","comments":false,"path":"friends/index.html","permalink":"http://www.okwzh.cn/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"'分布式ID雪花算法(snowflake)'","slug":"雪花算法-snowflake","date":"2020-06-14T09:43:19.000Z","updated":"2020-06-14T11:12:09.812Z","comments":true,"path":"2020/06/14/雪花算法-snowflake/","link":"","permalink":"http://www.okwzh.cn/2020/06/14/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-snowflake/","excerpt":"唯一ID可以标识数据的唯一性，在分布式系统中生成唯一ID的方案有很多，常见的方式大概有以下三种： 依赖数据库，使用如MySQL自增列或Oracle序列等。根据UUID生成snowflake雪花算法","text":"唯一ID可以标识数据的唯一性，在分布式系统中生成唯一ID的方案有很多，常见的方式大概有以下三种： 依赖数据库，使用如MySQL自增列或Oracle序列等。根据UUID生成snowflake雪花算法 为什么使用snowflake生成ID使用uuid生成订单号这类东西也能凑合用，但是它有着罄竹难书的“罪行”：肉眼可见，它是无序的；长度是64位数字字母随机组合的字符串，占用空间巨大；完全不具备业务属性，也就是说使用uuid你完全无法推算出它到底是干嘛的；因为无序，所以趋势递增就更不用指望了；所以用uuid生成订单号就是自杀行为，适合它的是类似生成token令牌的场景。 雪花算法(snowflake)是Twitter开源的分布式ID生成算法，结果是一个long型的ID。为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序，让twitter可以通过一定的索引来进行检索，而在Twitter庞大的分布式系统中不同机器产生的id必须又必须不同。它的好处显而易见，不仅全局唯一，并且有序按时间递增，同时占用空间少，生成的id仅仅是19位的整形数字，正好契合mysql的bigint数据类型，简直完美。 核心思想其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。组成： 优势整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。 可以根据自身业务特性分配bit位，非常灵活。 缺陷强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。 安装库1pip install pysnowflake 开启服务1snowflake_start_server --work&#x3D;1 12指定端口开启服务snowflake_start_server --work=1 --port=端口号 服务信息123456import snowflake.clientprint(snowflake.client.get_stats())#worker是服务信息,time是时间戳#&#123;'dc': 0, 'worker': 1, 'timestamp': 1592131606294, 'last_timestamp': 550281600000, 'sequence': 0, 'sequence_overload': 0, 'errors': 0&#125; 获取ID12345import snowflake.clientprint(snowflake.client.get_guid())#4369836784469676033 根据ID反解析服务123456789101112131415import snowflake.clientsid = snowflake.client.get_guid()print(sid)#ID：4369838396760133633bid = bin(sid)print(bid)#第一位是标识符，此后是41位的时间戳，紧接着10位的节点标识码，最后12位的递增序列，# 从后面数12位是：000000000001，再数5位是：00001 这5位就是某个节点的存储标识，我们就二进制的00001转换为十进制#0b11110010100100110010001101111010010100110000000001000000000001cid = bin(sid)[47:52]print('存储节点',cid)#存储节点 00001print('反解析服务',int(cid,2))#反解析服务 1","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'关于js数字过长出现的精度丢失问题'","slug":"关于js数字过长出现的精度丢失问题","date":"2020-06-14T07:37:27.000Z","updated":"2020-06-14T09:31:50.787Z","comments":true,"path":"2020/06/14/关于js数字过长出现的精度丢失问题/","link":"","permalink":"http://www.okwzh.cn/2020/06/14/%E5%85%B3%E4%BA%8Ejs%E6%95%B0%E5%AD%97%E8%BF%87%E9%95%BF%E5%87%BA%E7%8E%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/","excerpt":"在JavaScript中，由于计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示。js的整数和浮点数都属于Number类型的，所有数字都是以64位浮点数形式存储。所以我们在前端打印的时候，发现一个很奇怪的问题，就是当console.log(1.00)时，我们发现打印结果是1,后边的.00都被舍去。虽然数值是正确的，但是和理想结果有些偏差。","text":"在JavaScript中，由于计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示。js的整数和浮点数都属于Number类型的，所有数字都是以64位浮点数形式存储。所以我们在前端打印的时候，发现一个很奇怪的问题，就是当console.log(1.00)时，我们发现打印结果是1,后边的.00都被舍去。虽然数值是正确的，但是和理想结果有些偏差。 针对雪花算法出现的问题在做雪花算法的时候，说过使用model中的bigint是最好的存储方式，但是在做的时候发现一个问题，就是在前端展示出现展示效果问题，话不多说，上代码 这是我保存数据库的结果 这是我后端获取数据 这是我前端获取数据的结果 但是在我前端获取数据结果的时候，发现了一件很怪异的事情，就是js自动将我的数据给修改了，也就是前16位都是对着的。经过测试发现，我的后端数据没有问题，在传递给前端的时候出现了差错，经过咨询和百度，发现了是js精度丢失的问题。最常用的解决办法就是使用字符串类型。于是我把数据库的bitint类型给改成了varchar。完美解决。 JavaScript的16位长度数字不变，超过就发生精度丢失问题。针对数字丢失问题，我做了实验。 16位数字没变12345mounted()&#123; console.log('最大安全数',1111111111111111)&#125;// 最大安全数 1111111111111111 17位发生变化12345mounted()&#123; console.log('最大安全数',11111111111111111)&#125;// 最大安全数 11111111111111112 20位发生变化1234mounted()&#123; console.log('最大安全数',11111111111111111111)&#125;// 最大安全数 11111111111111110000 根据以上代码，我们可以清晰看到在16位整数可以发现数字没有变化，但是在第17位的时候就发生了变化，长度越长后边都以0显示。 解决办法:对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"},{"name":"js","slug":"js","permalink":"http://www.okwzh.cn/tags/js/"}]},{"title":"'uuid生成唯一id'","slug":"uuid生成唯一id","date":"2020-06-14T07:36:27.000Z","updated":"2020-06-14T08:14:01.790Z","comments":true,"path":"2020/06/14/uuid生成唯一id/","link":"","permalink":"http://www.okwzh.cn/2020/06/14/uuid%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80id/","excerpt":"当我们在做订单号的时候，可以发现我们使用订单号有个硬性条件，就是它最好的唯一性的,且最好是自增长。在我们python中，系统自带了一个唯一的模块，就是uuid。但是我们使用uuid来生成订单号虽然也能使用，但是却有一个致命的缺点，就是无序。","text":"当我们在做订单号的时候，可以发现我们使用订单号有个硬性条件，就是它最好的唯一性的,且最好是自增长。在我们python中，系统自带了一个唯一的模块，就是uuid。但是我们使用uuid来生成订单号虽然也能使用，但是却有一个致命的缺点，就是无序。 关于UUID(univeral unique identifier)uuid是128位的全局唯一标识符（univeral unique identifier），通常用32位的一个字符串的形式来表现。python中自带了uuid模块来进行uuid的生成和管理工作。在python中的uuid模块是基于MAC地址、时间戳、命名空间、随机数、伪随机数来生成的。 uuid.uuid1() 基于MAC地址，时间戳，随机数来生成唯一的uuid，可以保证全球范围内的唯一性。 1234import uuidprint(uuid.uuid1())#b8200238-ae14-11ea-859b-68ecc5357e24 uuid.uuid2() uuid.uuid2()算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。不过需要注意的是python中没有基于DCE的算法，所以python的uuid模块中没有uuid2这个方法。 uuid.uuid3() 通过计算一个命名空间和名字的md5散列值来给出一个uuid，所以可以保证命名空间中的不同名字具有不同的uuid，但是相同的名字就是相同的uuid了。namespace并不是一个自己手动指定的字符串或其他量，而是在uuid模块中本身给出的一些值。比如uuid.NAMESPACE_DNS，uuid.NAMESPACE_OID，uuid.NAMESPACE_OID这些值。这些值本身也是UUID对象，根据一定的规则计算得出。 1234567import uuidname = 'uuid_name'namespace = uuid.NAMESPACE_URLprint(uuid.uuid3(namespace,name))#5b4c833b-b8f0-36de-84d3-5ab20550d1c6 uuid.uuid4() 通过伪随机数得到uuid，是有一定概率重复的 12345import uuidprint(uuid.uuid4())#1c0f445e-a357-4568-a9bc-25e0b4c07330 uuid.uuid5() 和uuid3基本相同，只不过采用的散列算法是sha1 1234567import uuidname = 'uuid_name'namespace = uuid.NAMESPACE_URLprint(uuid.uuid5(namespace,name))#87fec518-b116-571f-87e3-e40ab834ff45","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"id","slug":"id","permalink":"http://www.okwzh.cn/tags/id/"}]},{"title":"'使用又拍云及拖拽上传'","slug":"day10-vue+django+python完成又拍云实现拖拽存储","date":"2020-06-09T02:28:35.000Z","updated":"2020-06-09T13:25:04.271Z","comments":true,"path":"2020/06/09/day10-vue+django+python完成又拍云实现拖拽存储/","link":"","permalink":"http://www.okwzh.cn/2020/06/09/day10-vue+django+python%E5%AE%8C%E6%88%90%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E5%AD%98%E5%82%A8/","excerpt":"官方网址：又拍云官网 1.点击注册或登录","text":"官方网址：又拍云官网 1.点击注册或登录 2.点击云存储 3.创建服务 4.查看又拍云图片 4.1分配的网址/图片名 http://md-upyun.test.upcdn.net/图片名 4.2进入文件管理查看 5.添加操作员 6.添加操作员 下载依赖 1pip install upyun 使用又拍云下载大文件1234567import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#文件流操作(节省内存)with open('./bg.png','rb') as f: #上传文件 res = up.put('/bg.png',f,checksum=True) 使用又拍云进行写入文件12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')value = 'hello python,恩呢恩'up.put('/yun.txt',value) 使用又拍云进行目录操作，创建文件夹12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#目录操作,创建文件夹up.mkdir('/ypyun_test/') 使用又拍云移动文件123456import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#移动文件#src移动谁，dest移动到哪up.move('bg.png','/ypyun_test/bg.png') 使用又拍云复制文件12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#复制文件up.copy('9c1d0bd8-8f51-11ea-a567-005056c00008.jpg','/ypyun_test/9c1d0bd8-8f51-11ea-a567-005056c00008.jpg') 使用又拍云断点续传1234567import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#断点续传(第二次传的时候是从第一次剩下的开始继续上传)with open('D:\\学习资料\\视频\\猫和老鼠.mp4','rb') as f:# need_resume=True断点续传 res = up.put('/ypyun_test/猫和老鼠.mp4',f,checksum=True,need_resume=True) 使用又拍云进行下载123456import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#下载图片res = up.get('/ypyun_test/9c1d0bd8-8f51-11ea-a567-005056c00008.jpg')print(res) 使用又拍云进行删除12345import upyun#新建又拍云实例up = upyun.UpYun('服务名称', username='操作员', password='生成密码')#删除up.delete('/ypyun_test/9c1d0bd8-8f51-11ea-a567-005056c00008.jpg') 拖拽上传代码示例vue代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;template&gt; &lt;div&gt; &lt;input type=\"file\" @change=\"upload_upyun\" /&gt; &lt;div class=\"upload\"&gt; 拖拽上传 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return&#123; &#125; &#125;, mounted () &#123; let upload = document.querySelector('.upload'); upload.addEventListener('dragenter', this.onDrag, false); upload.addEventListener('dragover', this.onDrag, false); upload.addEventListener('drop', this.onDrop, false); &#125;, //自定义方法 methods:&#123; onDrag (e) &#123; e.stopPropagation(); e.preventDefault(); &#125;, onDrop (e) &#123; e.stopPropagation(); e.preventDefault(); this.upload_upyun(e.dataTransfer.files); &#125;, //上传又拍云 upload_upyun:function(files)&#123; //获取文件对象 // let file = e.target.files[0]; let file = files[0]; //声明参数 let param = new FormData(); param.append('file',file); const config = &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125; this.axios(&#123; url:'http://localhost:8000/ypy/', method:'POST', data:param, config:config &#125;).then(resp=&gt;&#123; console.log(resp) &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.upload &#123; margin: 100px auto; width: 300px; height: 150px; border: 2px dashed #f00;&#125;&lt;/style&gt; django代码： 12345678910111213141516171819urls： path('ypy/',UpyunLoad.as_view()),import upyun# 定义文件上传类class UpyunLoad(APIView): def post(self, request): #前端获取文件 img = request.FILES.get('file') #创建文件名 file_name = str(uuid.uuid1())+'.jpg' print(file_name) up = upyun.UpYun('你的空间服务名称', username='操作员', password='生成密码') #x-gmkerl-rotate 旋转角度，目前只允许设置：auto，90，180，270 headers = &#123;'x-gmkerl-rotate': 'auto'&#125; for chunk in img.chunks(): res = up.put('/%s'%file_name, chunk, checksum=True, headers=headers) # 返回结果 return Response(&#123;'filename': file_name&#125;)","categories":[{"name":"又拍云","slug":"又拍云","permalink":"http://www.okwzh.cn/categories/%E5%8F%88%E6%8B%8D%E4%BA%91/"}],"tags":[{"name":"又拍云","slug":"又拍云","permalink":"http://www.okwzh.cn/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"异步","slug":"异步","permalink":"http://www.okwzh.cn/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"'结合又拍云实现多线程异步分块上传'","slug":"结合又拍云实现多线程异步分块上传","date":"2020-06-09T02:28:35.000Z","updated":"2020-06-09T14:07:40.250Z","comments":true,"path":"2020/06/09/结合又拍云实现多线程异步分块上传/","link":"","permalink":"http://www.okwzh.cn/2020/06/09/%E7%BB%93%E5%90%88%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E5%88%86%E5%9D%97%E4%B8%8A%E4%BC%A0/","excerpt":"上一篇我们已经说过又拍云的常用操作,今天我们讲一下结合多线程实现异步上传 当我们使用第三方依赖，要注意模块是不是最新依赖，进行更新 UPYUN Python SDK文档：点击跳转查看最新python SDK：点击跳转","text":"上一篇我们已经说过又拍云的常用操作,今天我们讲一下结合多线程实现异步上传 当我们使用第三方依赖，要注意模块是不是最新依赖，进行更新 UPYUN Python SDK文档：点击跳转查看最新python SDK：点击跳转 多线程异步实现又拍云上传1234567891011121314151617181920212223242526272829303132import upyun # 又拍云import os # 文件模块import threading # 多线程模块# 新建又拍云实例# 三个参数,又拍云服务名称，操作员名称，操作员密码up = upyun.UpYun('服务名称', '操作员名称', '操作员密码')# 分块上传uploader = up.init_multi_uploader('/upyun_python/upyun_sanguo.mp4')#同步上传# uploader.upload(0,os.urandom(1024*1024))# uploader.upload(1,os.urandom(1024*1024))#采用多线程调用上传#创建线程池threads = []#uploader.upload不加括号，这里是声明，不是调用，调用的话还是同步#参数写在args里,(0声明异步上传序号)t1 = threading.Thread(target=uploader.upload,args=(0,os.urandom(1024*1024)))# #添加到线程池threads.append(t1)t2 = threading.Thread(target=uploader.upload,args=(1,os.urandom(1024*1024)))threads.append(t2)#启动多线程for t in threads: t.start()# #阻塞主线程 t.join()## # #声明调用结束res = uploader.complete() 多线程异步对文件进行分块上传123456789101112131415161718#上传又拍云文件class Upyun_Post(APIView): def post(self,request): # 获取视频文件 file = request.FILES.get('file') print(file) up = upyun.UpYun('服务名称', '操作员名称', '操作员密码') uploader = up.init_multi_uploader(\"/upyun-python-sdk/%s\" % file, part_size=(1024 * 2048)) threads = [] for index, value in enumerate(file.chunks(chunk_size=(1024 * 2048))): t = threading.Thread(target=uploader.upload, args=(index, value)) threads.append(t) for i in threads: i.start() i.join() res = uploader.complete() return Response(&#123;'code':200,'message':'上传成功'&#125;) # return HttpResponse(json.dumps(&#123;'filename': file&#125;), content_type='application/json')","categories":[{"name":"又拍云","slug":"又拍云","permalink":"http://www.okwzh.cn/categories/%E5%8F%88%E6%8B%8D%E4%BA%91/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"又拍云","slug":"又拍云","permalink":"http://www.okwzh.cn/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"异步","slug":"异步","permalink":"http://www.okwzh.cn/tags/%E5%BC%82%E6%AD%A5/"},{"name":"多线程","slug":"多线程","permalink":"http://www.okwzh.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"'响应状态码和请求方法'","slug":"响应状态码","date":"2020-06-08T10:28:33.000Z","updated":"2020-06-08T10:43:16.589Z","comments":true,"path":"2020/06/08/响应状态码/","link":"","permalink":"http://www.okwzh.cn/2020/06/08/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"状态码分类(HTTP Status Code)123451XX- 信息型，服务器收到请求，需要请求者继续操作。2XX- 成功型，请求成功收到，理解并处理。3XX - 重定向，需要进一步的操作以完成请求。4XX - 客户端错误，请求包含语法错误或无法完成请求。5XX - 服务器错误，服务器在处理请求的过程中发生了错误。","text":"状态码分类(HTTP Status Code)123451XX- 信息型，服务器收到请求，需要请求者继续操作。2XX- 成功型，请求成功收到，理解并处理。3XX - 重定向，需要进一步的操作以完成请求。4XX - 客户端错误，请求包含语法错误或无法完成请求。5XX - 服务器错误，服务器在处理请求的过程中发生了错误。 常用状态码12345678910111213141516171819100系列： 100 继续 客户端应当继续发送请求200系列： 200 成功 服务器成功处理了请求300系列： 301 永久移动 请求的网页已永久移动到新位置，永久重定向 302 临时移动 请求的网页暂时跳转到其他页面，临时重定向400系列： 400 错误请求 服务器无法解析该请求 401 未授权 请求没有进行身份验证或验证未通过 403 禁止访问 服务器拒绝此请求 404 未找到 服务器找不到请求的网页500系列： 500 服务器内部错误 服务器遇到错误，无法完成请求 501 未实现 服务器不具备完成请求的功能 502 错误网关 服务器做为网关或代理，从上游服务器收到无效响应 504 网关超时 服务器做为网关或代理，但是没有及时从上游服务器收到请求 505 HTTP版本不支持 服务器不支持请求中所用的HTTP协议版本 请求方法1234567891011121314151).GET：请求页面，并返回页面内容 2).POST：用于提交表单数据或上传文件，数据包含在请求体中3).PUT：从客户端向服务器传送的数据取代指定文档中的内容4).DELETE：请求服务器删除指定的页面5).CONNECT：把服务器当做跳板，让服务器代替客户端访问其他网页6).HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头7).OPTIONS：允许客户端查看服务器的性能8).TRACE：回显服务器收到的请求，主要用于测试或诊断#重点掌握GET&amp;POST区别： 1.GET请求中的参数包含在URL里面，数据可以在URL中看到。而POST请求的URL不会包含这些数据，POST的数据都是通过表单形式传输的，会包含在请求体中。 2.GET请求提交的数据最多之后1024字节，而POST方式没有限制 3.POST请求比GET请求相对安全。 请求响应步骤1客户端连接到Web服务器-&gt;发送Http请求-&gt;服务器接受请求并返回HTTP响应-&gt;释放连接TCP连接-&gt;客户端浏览器解析HTML内容","categories":[{"name":"协议","slug":"协议","permalink":"http://www.okwzh.cn/categories/%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://www.okwzh.cn/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"状态码","slug":"状态码","permalink":"http://www.okwzh.cn/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"请求方法","slug":"请求方法","permalink":"http://www.okwzh.cn/tags/%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"}]},{"title":"'HTTP协议和HTTPS协议'","slug":"HTTP协议和HTTPS协议","date":"2020-06-08T09:21:21.000Z","updated":"2020-06-08T10:29:45.717Z","comments":true,"path":"2020/06/08/HTTP协议和HTTPS协议/","link":"","permalink":"http://www.okwzh.cn/2020/06/08/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE/","excerpt":"HTTP协议和HTTPS协议的概念1234567HTTP协议(Hyper Text Transfer Protocol)：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）， 用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS协议：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层， HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种： 1.一种是建立一个信息安全通道，来保证数据传输的安全； 2.另一种就是确认网站的真实性。","text":"HTTP协议和HTTPS协议的概念1234567HTTP协议(Hyper Text Transfer Protocol)：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）， 用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS协议：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层， HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种： 1.一种是建立一个信息安全通道，来保证数据传输的安全； 2.另一种就是确认网站的真实性。 HTTP协议的缺点1234HTTP缺点： 1.通信使用明文，内容可能被窃听(重要密码泄露) 2.不验证通信方身份，有可能遭遇伪装(跨站点请求伪造) 3.无法证明报文的完整性，有可能已遭篡改(运营商劫持) http和https的区别与联系及特点123456789101112 HTTP协议是超文本传输协议，被用于在Web浏览器和网站服务器之间传递信息的，是一个基于请求与响应，无状态的，应用层的协议，是TCP&#x2F;IP协议传输数据，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作无连接：每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。SSL：网景公司设计了SSL（SecureSocketsLayer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 HTTPS和HTTP的区别主要如下：123451、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl（安全套接字层SSL）加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。5、https相对于http协议的连接方式来讲，性能方面会有所损耗。 HTTPS的工作流程123456第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。第五步：Web服务器利用自己的私钥解密出会话密钥。第六步：Web服务器利用会话密钥加密与客户端之间的通信。 HTTPS的优缺点12345678910111213141516171819优点： 1.SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 2.安全性： （1）、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议， 要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 缺点： 1.SEO方面： （1）使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电 （2）HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。 （3）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 （4）成本增加。 2.经济方面： (1)SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 (2)HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采 (3)HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响 免费HTTPS证书推荐(排名不分先后)12345678SSL 证书级别分为三种类型，域名型SSL证书（DV SSL）、企业型SSL证书（OVSSL）、增强型SSL证书（EVSSL）(1).Let's Encrypt (2).startSSL(3).Wosign沃通SSL(4).NameCheap (5).腾讯云DV SSL 证书(6).阿里云DV SSL证书(7).360网站卫士、百度云加速免费SSL、又拍云、七牛云","categories":[{"name":"协议","slug":"协议","permalink":"http://www.okwzh.cn/categories/%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://www.okwzh.cn/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"'结合百度ai实现自然语言分析'","slug":"结合百度AI实现自然语言分析","date":"2020-06-07T13:25:36.000Z","updated":"2020-06-07T13:49:49.045Z","comments":true,"path":"2020/06/07/结合百度AI实现自然语言分析/","link":"","permalink":"http://www.okwzh.cn/2020/06/07/%E7%BB%93%E5%90%88%E7%99%BE%E5%BA%A6AI%E5%AE%9E%E7%8E%B0%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"百度AI开放平台地址：点击跳转官方文档地址：点击跳转","text":"百度AI开放平台地址：点击跳转官方文档地址：点击跳转 获取应用1.进行注册登陆2.找到文字识别–&gt;应用列表3.创建应用4.获取AppID,API Key,Secret Key 安装百度AI模块 1pip install baidu-aip 对文本进行错误检查123456789101112131415from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#定义检查文本text = '学习python，学习人工只能'#进行检查res = client.ecnet(text)print(res)#&#123;'log_id': 9052624029983259239, 'item': &#123;'vec_fragment': [&#123;'ori_frag': '人工只能', 'begin_pos': 16, 'correct_frag': '人工智能', 'end_pos': 24&#125;], 'score': 0.590899, 'correct_query': '学习python，学习人工智能'&#125;, 'text': '学习python，学习人工只能'&#125; 对文本进行标签处理12345678910111213141516from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#标签title = 'python人工智能在线学习'content = '我再北京学习人工智能，他是基于python的一门学科'#调取标签res = client.keyword(title,content)print(res)#&#123;'log_id': 2174377746871861863, 'items': [&#123;'score': 0.9486, 'tag': '人工智能'&#125;, &#123;'score': 0.768706, 'tag': 'python'&#125;]&#125; 对文本进行情感分析12345678910111213from aip import AipNlpappip = 'your appid'appkey = 'your appkey'secret_key = 'your secret_key'#实例化对象client = AipNlp(appip,appkey,secret_key)#情感分析text = '华为是一家很棒的公司'print(client.commentTag(text))#&#123;'log_id': 1058331879559622439, 'items': [&#123;'sentiment': 2, 'abstract': '华为是一家很棒的公司&lt;span&gt;&lt;/span&gt;', 'prop': '感觉', 'begin_pos': 20, 'end_pos': 20, 'adj': '棒'&#125;]&#125;","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'第三方登录-gitee登录'","slug":"第三方登录-gitee登录","date":"2020-06-06T08:00:02.000Z","updated":"2020-06-06T08:36:09.287Z","comments":true,"path":"2020/06/06/第三方登录-gitee登录/","link":"","permalink":"http://www.okwzh.cn/2020/06/06/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-gitee%E7%99%BB%E5%BD%95/","excerpt":"创建gitee应用1.登陆gitee","text":"创建gitee应用1.登陆gitee gitee登录网站2.点击头像,设置,第三方应用3.创建应用4.自定义应用名称，应用描述，应用回调网址等。5.创建完成，获取Client ID,Client Secret,还有应用回调地址。 gitee开发文档开发文档地址：点击跳转 代码实例12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;img :src=\"'http://localhost:8000/static/mayun.png'\" alt=\"\" @click=\"gitee_login\" &gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, methods:&#123; //第三方登录--&gt;gitee登录 gitee_login()&#123; var client_id = '8778f21baf13e5a37d2d5d74b66dc74b2716d4f44d18bed2f08f02c229142812' var back = 'http://localhost:8000/gitee_back' var url = 'https://gitee.com/oauth/authorize?client_id='+client_id+'&amp;redirect_uri='+back+'&amp;response_type=code' window.location.href = url &#125;, &#125; &#125; 6.获取code来换取access_token 12345678910111213141516171819#gitee三方登录url: path('gitee_back',Gitee_Back.as_view()), #gitee回调class Gitee_Back(APIView): def get(self,request): code = request.GET.get('code') print(code) redirect_uri = 'http://localhost:8000/gitee_back' # url = 'https://gitee.com/oauth/authorize?client_id='+ CLIENT_ID +'&amp;redirect_uri=' + redirect_uri +'&amp;response_type=code' data = &#123; 'client_id':CLIENT_ID, 'client_secret':CLIENT_SECRET, 'redirect_uri':redirect_uri, 'code':code, 'grant_type': 'authorization_code' &#125; url = 'https://gitee.com/oauth/token?grant_type=authorization_code&amp;code='+code+'&amp;client_id='+ CLIENT_ID +'&amp;redirect_uri='+ redirect_uri +'&amp;client_secret='+CLIENT_SECRET res = requests.post(url=url,data=data) print(res.json()) 7.点击开发文档，API文档，用户账户，获取授权用户资料，申请授权 12345678910111213141516171819# 接上access_token = res.json()['access_token']#获取tokentoken_uri = 'https://gitee.com/api/v5/user?access_token=' +access_tokenres = requests.get(url=token_uri)print(res.json())user_id = ''username = str(res.json()['name'])user = User.objects.filter(username=username).first()if user: #表示曾经登陆过 user_id= int(res.json()['id']) user.username = username print('已经登录过,id是%s,名字是%s'%(user.id,user.username))else: user = User(username=username,id=int(res.json()['id']),password=make_password(\"\")) user.save() user_id = user.id print('第一次注册，id是%s,名字是%s'%(user.id,user.username))return redirect('http://localhost:8080/?user_id='+str(user_id)+'&amp;username='+username)","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'VOLANTIS博客的搭建'","slug":"VOLANTIS博客的搭建","date":"2020-06-05T07:30:08.000Z","updated":"2020-06-05T13:46:19.416Z","comments":true,"path":"2020/06/05/VOLANTIS博客的搭建/","link":"","permalink":"http://www.okwzh.cn/2020/06/05/VOLANTIS%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置","text":"站点配置_config.yml是你的博客设置 主题配置_config.yml是你的博客主题设置 配置博客主题为VOLANTIS123#在站点配置_config.yml中修改blog/_config.ymltheme: volantis 配置博客主题标题123#在站点配置_config.yml中修改blog/_config.ymltitle: 你博客主题名称 front-matter12345678---cover: true/false #设置封面------ #参考资料references: - name: Apple Developer Documentation url: https://developer.apple.com/documentation/---","categories":[],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://www.okwzh.cn/tags/hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"'jieba库的安装使用'","slug":"jieba库的安装使用","date":"2020-06-04T03:00:26.000Z","updated":"2020-06-04T03:07:58.657Z","comments":true,"path":"2020/06/04/jieba库的安装使用/","link":"","permalink":"http://www.okwzh.cn/2020/06/04/jieba%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"jieba库的安装 1pip install jieba","text":"jieba库的安装 1pip install jieba jieba库的使用12345678910111213141516171819202122232425262728293031323334import jieba.analysedata = \"Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。\" \\ \"Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。\"#提取标签for keyword,weight in jieba.analyse.extract_tags(data,withWeight=True): print('%s:%s' % (keyword,weight))#输出内容# Building prefix dict from the default dictionary ...# Loading model from cache C:\\Users\\10186\\AppData\\Local\\Temp\\jieba.cache# Loading model cost 0.878 seconds.# Prefix dict has been built successfully.# Python:1.1385492859904762# 数据类型:0.585297130452381# Guido:0.5692746429952381# van:0.5692746429952381# Rossum:0.5692746429952381# 1989:0.5692746429952381# 1991:0.5692746429952381# 发行版:0.5270221099# 面向对象:0.5067895768571429# 程序设计:0.44264321266619044# 发明:0.31970364912190474# 动态:0.3195238865542857# 高级:0.3114256070914286# 语言:0.29349988448285713# 第一个:0.28425680430714284# 解释:0.2720391527752381# 年底:0.2701318006847619# 公开:0.26735277138999997# 发行:0.22793990734714284# 一种:0.19674458076142856","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'无限极分类'","slug":"无限极分类","date":"2020-06-03T12:19:22.000Z","updated":"2020-06-03T12:51:18.600Z","comments":true,"path":"2020/06/03/无限极分类/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/","excerpt":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样.","text":"什么是无限极分类呢？ 无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样. 无限极分类 12345678910衣服 上衣 短袖 卫衣 裤子 牛仔裤 休闲裤 鞋子 运动鞋 休闲鞋 无限极分类应用场景很广泛，例： 帖子的回复功能 课程的目录章节 基于python,结合django+vue实现无限极分类(递归层级结构)在myapp中model.py文件下 123456789class Cate(models.Model): #id是主键，自增 #分类名称 name = models.CharField(max_length=200,null=True) #父级分类id pid = models.IntegerField() class Meta: db_table = 'cate' 数据库配置数据 使用drf框架进行序列化 123456789#导包from rest_framework import serializersfrom .models import Cate#序列化类class CateSer(serializers.ModelSerializer): class Meta: model = Cate fields = '__all__' 写一个用来进行递归的方法，进行层级结构划分 12345678910111213141516def Xtree(datas): lists = [] tree = &#123;&#125; for item in datas: tree[item['id']] = item print(tree[item['id']]) for i in datas: if not i['pid']: root = tree[i['id']] lists.append(root) else: parent_id = i['pid'] if 'child' not in tree[parent_id]: tree[parent_id]['child'] = [] tree[parent_id]['child'].append(tree[i['id']]) return lists 写视图接口并分配路由 123456789101112from .myser import CateSerfrom .cengji import Xtree# 递归层级分类class MyTree(APIView): def get(self,request): cates = Cate.objects.all() ser = CateSer(cates,many=True) trees = Xtree(ser.data) return Response(trees)#分配url# path('tree/',MyTree.as_view()), 测试接口 前端使用递归组件渲染所谓递归组件: 就是组件可以在它们自己的模板中调用自身，不过它们只能通过 name 选项来做这件事，例如给组件设置属性 name: ‘Reply’，然后在模板中就可以使用 Reply 调用自己进行递归调用了 设置Reply.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;li&gt; &lt;div :class=\"[data.id==0 ? 'root':'','reply']\"&gt; &#123;&#123;data.name&#125;&#125; &lt;/div&gt; &lt;ul v-if=\"data.child &amp;&amp; data.child.length&gt;0\"&gt; &lt;Reply v-for=\"c in data.child\" :key=\"c.id\" :data=\"c\"&gt;&lt;/Reply&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:\"Reply\",//递归需要设置name属性，才能在模板中调用自身 data()&#123; return&#123; &#125; &#125;, props:['data'], mounted() &#123; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.reply&#123; padding-left: 4px; border-left: 1px solid #eee;&#125;ul&#123; padding-left: 20px; list-style: none;&#125;.root&#123; display: none;&#125;&lt;/style&gt; 在其他组件调用Reply.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- import cengji from '@/components/cengji'&#123; path:'/cengji', name:'cengji', component:cengji&#125;, --&gt;&lt;template&gt; &lt;div&gt; &lt;Reply :data=\"data\"&gt;&lt;/Reply&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// import &#123;config,formatXml&#125; from '../config'// import mh_test from './mh_test.vue'import Reply from './Reply'// import md5 from 'js-md5'export default &#123; data()&#123; return&#123; data:&#123;&#125;, online:0, &#125; &#125;, components:&#123; Reply &#125;, mounted() &#123; this.get_token() &#125;, methods: &#123; get_token()&#123; this.axios(&#123; url:\"http://localhost:8000/tree/\", method:\"GET\" &#125;).then(resp=&gt;&#123; console.log(resp) var tree = &#123;'id':0,name:\"123\"&#125; tree['child'] = resp.data this.data = tree console.log(this.data) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.on &#123; background: #cdcbff;&#125;.off &#123;background: #fefdff;&#125;&lt;/style&gt; 前端结果展示","categories":[],"tags":[]},{"title":"'算法-斐波那契数列'","slug":"算法-斐波那契数列","date":"2020-06-03T07:39:35.000Z","updated":"2020-06-03T07:58:49.369Z","comments":true,"path":"2020/06/03/算法-斐波那契数列/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）","text":"斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 递归斐波那契数列(写法最简洁，但是效率最低，会出现大量的重复计算，时间复杂度O（1.618^n）,而且最深度1000) 12345678910def fib_func(n): # 定义出口 if n &lt;= 1: return 1 return func(n-1)+func(n-2) #第一位数和第二位数相加的结果for i in range(10): print(fib_func(i),end=\" \")#1 1 2 3 5 8 13 21 34 55 生成器斐波那契数列带有yield的函数都被看成生成器，生成器是可迭代对象，且具备iter 和 next方法， 可以遍历获取元素python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现iter方法，而iter方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的iter方法返回自身即可 1234567891011def fib_func(max): n,a,b = 0,0,1 while n &lt; max: yield b a,b = b,a+b n += 1fib_list = fib_func(10)for i in fib_list: #使用for循环遍历 print(i,end=\" \")#1 1 2 3 5 8 13 21 34 55","categories":[],"tags":[]},{"title":"'python算法'","slug":"python算法","date":"2020-06-03T07:22:27.000Z","updated":"2020-06-03T07:37:09.140Z","comments":true,"path":"2020/06/03/python算法/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/python%E7%AE%97%E6%B3%95/","excerpt":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。","text":"排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。 常用排序算法： 1234567冒泡排序(*****)选择排序(*****)插入排序快速排序希尔排序归并排序堆排序 搜索是在一个项目集合中找到一个特定项目的算法过程。 常用排序算法： 1234顺序查找二分法查找（*****）二叉树查找哈希查找","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'redis命令即使用'","slug":"redis","date":"2020-06-03T01:39:25.000Z","updated":"2020-06-08T06:44:30.166Z","comments":true,"path":"2020/06/03/redis/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/redis/","excerpt":"Redis的安装","text":"Redis的安装 Reids官网：https://redis.io/ 1234567#Redis的安装： 1).下载地址：可以在官网下载最新版本 2).在该文件夹下输入cmd,进入黑窗口：'redis-server ./redis.windows.conf',可以看到运行效果图。基于C/S架构 #如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略,是默认的。 3).运行：另启动一个cmd窗口，输入'redis-cli',当看到'127.0.0.1:6379'时，就可以启动成功了 #注意：原来的reids-server窗口不能关闭，不然就无法访问服务端了。 4).'127.0.0.1:6379':127.0.0.1是本机ip，6379是Reids的服务端口，输入ping命令，返回PONG，就证明成功了。 Redis的数据类型1234567#Redis的数据类型： Redis支持五种数据类型： string（字符串） #二进制安全，可以包含任何数据，最大存储512MB hash（哈希） #键值对集合，适用于存储对象。 list（列表） #简单的字符串列表，按照插入顺序排序， set（集合） #无序集合，时间复杂O(1),元素唯一，存在返回0 zset(sorted set：有序集合) #有序集合，不能重复，不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。 Redis的定义12#Redis的定义： redis是一个key-value存储系统。redis的操作都是原子性的，redis支持各种不同方式的排序，redis的数据都是缓存在内存中。redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis的优势12345678910111213141516#redis介绍： 1).redis是使用C语言开发，支持网络，可基于内存亦可持久化的日志型key-value数据库，为开发语言提供多种API 2).redis存储数据，可以将内存中的数据保存在磁盘中，重启可以再次加载。 3).redis分为几种类型 4).redis支持数据备份，master-slave模式的数据备份--&gt;master:主人，slave：奴隶--&gt;主从模式#Redis的优势： 1).性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 2).丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 3).原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 4).丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 #redis的应用场景： 1).用来做缓存 --- redis的所有数据是放在内存中（内存型的数据库） 2).可以应用在某些特定的场景，比如社交类应用 3).在一些大型的系统中，巧妙的实现一些特定的功能：购物车，session的共享 Redis的命令123451).启动redis服务器： redis-server2).连接redis服务器： redis-cli3).远程服务执行命令： redis-cli -h host -p port -a password#例：连接到主机为127.0.0.1,端口为6379,密码为123的redis服务上 redis-cli -h 127.0.0.1 -p 6379 -a '123'#中文乱码： redis-cli --raw Redis keys命令1234567891011121).set key value 添加key值 2).get key 获取key值3).del key key存在，删除key值4).dump key 序列化给定key，返回被序列化得值5).exists key 检查key是否存在6).expire key seconds(秒数) 给key设置过期时间，以秒计时7).keys */key 获取key名称8).persist key 取消key的过期时间，key将永久保持9).ttl key 以秒为单位，返回key的剩余过期时间10).randomkey 从数据库随机返回一个key11).rename key newkey 修改key名字12).type key 返回key所储存的值的类型 Redis string命令123456781).getrange key start end 返回key中value的值，从0开始2).getset key value 将oldvalue改为newvalue，返回oldvalue3).mget key1 key2 key3 获取多个key值4).strlen key 返回value的长度5).mst key1 value1 key2 value2 同时设置一个或多个key-value对6).append key value 将指定的 value 追加到该 key 原来值（value）的末尾。7).incr key 将key中储存的数字值+18).decr key 将key中储存的数字值-1 Redis hash命令123456789101112 (key=hash表，field=字段，value=值)Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象 1).hmset key filed1 value1 field2 value2 创建一个hash表key，指定字段和value 2).hdel key field1 field2 删除一个或多个hash表 3).hexists key field1 查看hash表中，指定field是否存在 4).hget key field 获取hash表指定字段得值 5).hgetall key 获取hash表所有字段和值 6).hkeys key 获取hash表中的字段 7).hlen key 获取hash表中字段的数量 8).hmget key field1 field2 获取hash表中给定字段的值 9).hset key field value 将hash表中字段得值设为value 10).hvals key 获取hash表中所有值 Redis list命令1234567891011Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 1).lpush key value1 value2 创建一个key列表，插入值 2).lrange key start end 查询key列表，从start到end之间的value 3).blpop key timeout 删除第一个元素， 4).brpop key timeout 删除最后一个元素 5).lindex key index 根据索引获取列表中的元素 6).llen key 获取列表长度 7).lpop key 删除并获取第一个元素 8).lpush key value1 value2 将一个或多个值插入列表头部 9).lpushx key value 将一个值插入到已存在的列表头部 10).rpop key 删除列表的最后一个元素，返回删除的元素 Redis set命令1234567891011Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 1).sadd key value1 value2 创建一个集合，添加一个或多个值 2).scard key 获取集合的值的数量 3).sinter key1 key2 返回给定集合的交集 4).sismember key value 判断value是否在集合key中 5).smembers key 返回集合中的所有value 6).smove key1 key2 value 将value从key1集合移动到key2集合 7).spop key count 随机删除key集合中的count个元素 8).srandmember key count 随机返回key集合中的count个元素 9).srem key value1 value2 删除集合中的value元素 Redis set命令12345678Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 1).zadd key(有序集合) 分数 value 创建一个集合，并给出分数 2).zadd key start end withscore(分数) 查询集合从start到end之间的value，带分数 3).zcard key 获取有序集合和数量 4).zcount key min max 计算在有序集合中指定区间分数的数量","categories":[{"name":"redis","slug":"redis","permalink":"http://www.okwzh.cn/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.okwzh.cn/tags/redis/"}]},{"title":"'递归算法'","slug":"递归算法","date":"2020-06-03T01:39:25.000Z","updated":"2020-06-03T02:44:40.904Z","comments":true,"path":"2020/06/03/递归算法/","link":"","permalink":"http://www.okwzh.cn/2020/06/03/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","excerpt":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?…","text":"有关递归算法的小故事从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢?… 什么是函数嵌套调用？什么是递归？123函数内部是可以调用其他函数的，这种调用就是函数的嵌套调用。递归就是&#39;函数在内部直接或间接调用自己本身&#39;。 使用递归的注意事项123451.必须有明确的退出条件2.每次进入更深一层递归时，问题规模比上次递归都有所减少3.递归到一定层次就会出现结果4.递归效率不高，递归层数过多会导致栈溢出(栈内存不够用)5.栈溢出默认是1000,但是当递归到998就已经报错了。 栈溢出错误：1栈溢出错误：RecursionError: maximum recursion depth exceeded in comparison 解决栈溢出的办法：123#修改递归深度的值import syssys.setrecursionlimit(2000) 关于栈溢出例子：12345678import syssys.setrecursionlimit(2000) #设置最大递归深度是2000def sum_digui_func(n): if n &lt;= 0: return 0 return n + sum_digui_func(n-1)#当我们运行到1997是，还是可以运行的。到1998就报错，所以可以认为比设置最大递归深度-3就是可以运行的。print(sum_digui_func(1997)) 说到递归就要说下逆向思维，在大部分情况下，人们所想的是都是片面，也就是有局限性。逆向思维就是突破这个局限性，从另一方面去想怎么解决这个事情。 逆向思维小故事 1234关于司马光砸缸： 讲述了司马光砸坏水缸，救出同伴的古诗。 在大部分情况下的人，当时所想的是如何让人脱离水，从而救出人。 我们通过逆向思维，想到也可以使水脱离人，从而脱救，于是把水缸砸坏，使水流光从而进行救助。 递归求和 1234567def sum_func(n): #设定出口，退出条件 if n &lt;= 0: return 0 #调用自身，每次和自身-1相加 return n + sum_func(n-1)print(sum_func(5)) 阶乘 1234567def ride_func(n): #设定出口，退出条件 if n &lt;= 1: return 1 #调用自身，每次和自身-1相乘 return n + ride_func(n-1)print(ride_func(5))","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"'设计模式之工厂模式'","slug":"设计模式之工厂模式","date":"2020-06-02T08:34:10.000Z","updated":"2020-06-02T11:18:57.349Z","comments":true,"path":"2020/06/02/设计模式之工厂模式/","link":"","permalink":"http://www.okwzh.cn/2020/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。","text":"工厂模式是一个在软件开发中用来创建对象的设计模式。是一个在软件开发中用来创建对象的设计模式。 工厂模式就是建立对象的类就是一个工厂，需要被建立的对象就是一个个产品；在工厂中加工的产品，使用产品的人不在乎产品是如何生产出来的。从开发角度来说，有效降低了模块之间的耦合度。 简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。简单工厂实例化的类具有相同的接口或者基类，在子类比较固定并不需要扩展时，可以使用简单工厂。如数据库生产工厂就是简单工厂的一个应用采用简单工厂的优点是可以使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性；缺点是可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂，不符合OCP（开闭原则）的原则。简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。 与django结合实现工厂模式 12345678910111213141516171819202122232425262728293031323334class WeiBo: def __repr__(self): return '使用微博进行第三方登录'class DingDing: def __repr__(self): return '使用钉钉进行第三方登录'class Gitee: def __repr__(self): return '使用马云进行第三方登录'#实例化类weibo = WeiBo()dingding = DingDing()gitee = Gitee()#简单工厂模式class Factory: #这里使用静态方法 @staticmethod def Login(name): if name == 'weibo': return WeiBo() elif name == 'dingding': return DingDing() elif name == 'gitee': return Gitee()factory = Factory.Login(\"weibo\")#当name==weibo，输出使用微博进行第三方登录#当name==dingding，输出使用使用钉钉进行第三方登录#当name==gitee，输出使用马云进行第三方登录print(factory)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'schedule的定时任务'","slug":"celery的定时任务","date":"2020-06-01T06:44:33.000Z","updated":"2020-06-02T11:18:18.841Z","comments":true,"path":"2020/06/01/celery的定时任务/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/celery%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"使用定时任务定时执行","text":"使用定时任务定时执行 启动定时任务命令 12在和manage.py文件同级目录下： celery -A mydjango beat -l info 注意： 1234启动定时任务需要启动三个服务1.django后台服务：python manage.py runserver2.selery后台服务：celery worker -A mydjango -l info -P eventlet3.定时任务服务：celery -A mydjango beat -l info 启动定时任务出现错误 12ERROR: Pidfile (celerybeat.pid) already exists.Seems we're already running? (pid: 29396) 这个错误就是说启动服务的文件夹里有启动文件celerybeat.pid了，把他删掉就可以了，记得再次重启 在settings中配置12345678910111213#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称,解析字符串寻找 'schedule':timedelta(seconds=7200) #定时时长 &#125;&#125; 结合Django使用一个小案例：每1分钟提交一次log文件12345678910111213141516171819202122232425262728在settings配置#定时任务#导入celery定时模块from celery.schedules import crontab#导入时间模块from datetime import timedeltaCELERY_BEAT_SCHEDULE = &#123; #定义定时任务 'celery_work':&#123; 'task':'myapp.tasks.async_test', #任务名称 'schedule':timedelta(seconds=60) #定时时长，,1分钟 &#125;&#125;创建一个task.py文件from celery.task import task#自定义异步任务@taskdef async_test(): print('异步任务') #文件名 filename = 'celeray.log' #追加形式写入 with open(filename,'a') as f: #写入文件时间 f.write(str(datetime.datetime.now())+'\\n') return '123123'","categories":[],"tags":[{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"}]},{"title":"'关于使用selery出现错误的问题'","slug":"关于使用selery出现错误的问题","date":"2020-06-01T03:38:28.000Z","updated":"2020-06-02T09:10:00.582Z","comments":true,"path":"2020/06/01/关于使用selery出现错误的问题/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8selery%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"启动celery命令 1celery worker -A celery_task -l info -P eventlet","text":"启动celery命令 1celery worker -A celery_task -l info -P eventlet 在django中使用restful风格做开发时，发现都不能发送在使用post方法的时候，因为我的celery后台一直是启动的，所以不运行task中封装的函数，然后一直在找解决办法，于是我重启celery后台，会出现一个错误 该错误描述： 1TypeError: wrap_socket() got an unexpected keyword argument '_context' 于是找了解决办法，换个启动命令request包的request.post发送后，传不回数据 所以，在改变服务器启动方法不要用eventlet，加个参数 1celery worker -A mydjango -l info -P=solo 来源: Apical转载于: https://www.sirxs.cn/2020/06/01/Note/celery_error/","categories":[],"tags":[]},{"title":"'celery异步的使用'","slug":"celery异步的使用","date":"2020-06-01T01:23:44.000Z","updated":"2020-06-02T09:10:16.863Z","comments":true,"path":"2020/06/01/celery异步的使用/","link":"","permalink":"http://www.okwzh.cn/2020/06/01/celery%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2","text":"使用celery异步需要的包 1234使用的版本： pip install django==2.0.4 pip install celery==4.4.2 pip install eventlet==0.25.2 django配置celery在settings中配置123456#代理url，异步任务代理CELERY_BROKER_URL = 'redis://localhost:6379/'#保存结果CELERY_RESULT_BACKEND = 'redis://localhost:6379/'#保存类型格式，使用jsonCELERY_RESULT_SERIALIZER = 'json' 在和settings同一级目录下，创建celery.py文件，进行配置文件，用来启动服务123456789101112131415# -*- coding: utf-8 -*-from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery# 设置环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mydjango.settings')# 注册Celery的APPapp = Celery('mydjango')# 绑定配置文件,声明命名空间,可以在电脑任何位置启动app.config_from_object('django.conf:settings', namespace='CELERY')# 自动发现各个app下的tasks.py文件app.autodiscover_tasks() 在和settings同一级目录下的init.py文件下，当启动服务，加载init.py文件配置12345678910from __future__ import absolute_import, unicode_literalsfrom .celery import app as celery_app#导包import pymysql#初始化pymysql.install_as_MySQLdb()#加载celery应用__all__ = ['celery_app'] 在myapp文件夹下，创建一个tasks.py文件，自定义任务123456789from celery.task import task#自定义异步任务#实用装饰器声明是异步任务@taskdef async_test(): print('异步任务') return '123123' 触发异步任务队列1234567#调用tasks异步from myapp import tasks#触发异步任务视图def celery_test(request): #使用delay()异步任务调用 res = tasks.async_test.delay() return JsonResponse(&#123;'task_id':res.task_id&#125;) 配置url12345from myapp.views import celery_testurlpatterns = [ #定义超链接路由 path('celery_test/',celery_test),] 启动celery服务1231.先启动django服务：python manage.py runserver2.在manage.py文件的同级目录下，启动celery服务3.以协程方式启动服务命令：celery worker -A mydjango -l info -P eventlet 实例:做邮件发送使用celery123456789101112131415161718192021222324252627282930313233343536373839404142#task中：from celery.task import taskfrom mydjango.settings import MY_MAIL,MY_PASSfrom email.mime.text import MIMETextfrom email.utils import formataddrimport smtplib@taskdef mail(subject,content,mailaddr): #声明邮件对象 msg = MIMEText(content,'plain','utf-8') #设置发送方对象 msg['From'] = formataddr(['在线教育平台',MY_MAIL]) #设置收件方对象 msg['To'] = formataddr(['尊敬的客户',mailaddr]) #设置标题 msg['Subject'] = subject #设置smtp服务器 server = smtplib.SMTP_SSL('smtp.qq.com',465) #登录邮箱 server.login(MY_MAIL,MY_PASS) #发送邮件 server.sendmail(MY_MAIL,[mailaddr],msg.as_string()) #关闭smtp连接，节约系统资源 server.quit()#退出#在视图中class Register(APIView): def post(self,request): email = request.data.get('email') #获取前端用户邮件 subject = '亲爱的用户您好：,欢迎注册在线教育平台' #邮件标题 yanzhengma = random.randint(1000,9999) print(yanzhengma) #数字验证码 r.set('email',yanzhengma,120) #存到redis print(123,r.get('email')) content = '欢迎注册在线教育平台，您的验证码是%s，请在2分钟内输入，失效请重新获取' % yanzhengma print(content) #邮件内容 mailaddr = email #给发送邮件 #参数需要存放到delay(里) send_email = tasks.mail.delay(subject, content, mailaddr) #异步发送邮件调用邮件 #使用celery需要使用JsonResponse返回 return JsonResponse(&#123;'code':200,'yzm':yanzhengma,'send_email':send_email.task_id&#125;)","categories":[],"tags":[{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"}]},{"title":"git","slug":"git","date":"2020-05-31T05:10:10.000Z","updated":"2020-06-04T05:09:00.090Z","comments":true,"path":"2020/05/31/git/","link":"","permalink":"http://www.okwzh.cn/2020/05/31/git/","excerpt":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。","text":"工作中的注意事项： 123注意： 在每天工作的第一件事就是先git pull拉取线上最新的版本。 每天下班前要做的就是git push，将本地代码提交到线上仓库。 Git的下载与安装1git的下载与安装:https:&#x2F;&#x2F;blog.csdn.net&#x2F;Dan_Xiao_Hui&#x2F;article&#x2F;details&#x2F;105637182 在Gitee上创建仓库12345678910111213141516171819202122232425在Gitee上创建仓库： 1.点击+号，新建仓库，如图1, 2.编辑仓库名，仓库路径，仓库描述，公开 3.点击创建创建git仓库： 1.创建一个文件夹cangku:mkdir cangku 2.进入文件夹：cd cangku 3.初始化git：git init 4.将要上传的文件添加到暂存区：git add -A 5.将暂存区文件提交到仓库：git commit -m &#39;描述&#39; 6.因为是第一次上传，所以需要确定好gitee的git仓库： git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;wang_zeng_hui&#x2F;cangku.git #####只有第一次上传，需要确定Git仓库位置，以后不需要 7.推送到云端：git push -u origin master需要用户名或密码：(只需要写入一次)(图4) git config --global user.name &quot;你登录gitee的名字&quot; git config --global user.email &quot;你登录的email&quot;删除仓库： 1.进入管理(如图5) 2.点击删除仓库(如图6) 3.根据要求输入内容(如图7) 4.登录账号,进行验证(如图8) 图1 图2 图3 图4 删除仓库图5 图6 图7 图8 Git的命令1234567891011121314Git的常用命令： 1.将线上网址克隆到本地：git clone git网址 2.将工作区的修改添加到暂存区：git add -A 3.将暂存区的文件提交到仓库：git commit -m &#39;描述&#39; 4.将仓库推送到云端：git push origin master其他命令： 清掉配置：git config --system --unset credential.helper 保存密码：git config --global credential.helper store 查看版本日志：git log 简单日志：git log --pretty&#x3D;oneline 回退操作：git reset --hard &#39;版本号&#x2F;日志&#39; 回退之后返回之前操作日志：git reflog git reset --hard &#39;版本号&#x2F;日志&#39; Git的分支命令123456789101112131415在我们每次提交之后都会有记录，Git把它们穿成时间线，形成类似于时间轴的东西。这个时间轴就是一个分支，我们称之为master分支。分支相关命令： 查看分支：git branch 查看所有分支：git branch -a 查看远端分支：git branch -r 创建并切换分支：git checkout -b 分支名 建立本地与线上分支关联：git push --set-upstream origin 分支名(可以不切换分支就能提交) 创建分支：git branch 分支名 切换分支：git checkout 分支名 合并分支：git merge 被合并的分支名（需要先切换到master分支） 删除分支：git branch -d 分支名 删除远程分支：git push origin --delete 分支名 注意：当我们进行删除分支的时候，注意要先退出要删除的分支，不然会报错。 Git的合并1234561.创建dev分支：git checkout -b dev2.将本地分支提交线上：git push --set-upstream origin dev3.切换master分支：git checkout master4.合并分支：git merge dev(直接push提交，不需要推送)5.合并之后推送到线上：git push origin master","categories":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/tags/git/"}]},{"title":"'序列化类的使用'","slug":"day13-序列化类的使用","date":"2020-05-10T02:13:08.000Z","updated":"2020-06-06T07:31:57.032Z","comments":true,"path":"2020/05/10/day13-序列化类的使用/","link":"","permalink":"http://www.okwzh.cn/2020/05/10/day13-%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"rest_framework的下载1pip install djangorestframework","text":"rest_framework的下载1pip install djangorestframework 在settings中注册rest_framework123456789101112INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'corsheaders', #后端跨域 'rest_framework', #rest_framework框架 'myapp', 'dwebsocket'] 在django的app中创建一个serializers.py文件12345678910111213#导包from rest_framework import serializers#导入需要序列化的表from myapp.models import *#建立序列化类class CarouselSer(serializers.ModelSerializer): #针对表进行序列化 class Meta: model = Carousel #表名 fields = '__all__' #所有字段 在views视图中123456789from myapp.myser import * #导入序列器class GetCarousel(APIView): def get(self,request): #读库 carousels = Carousel.objects.all() #序列化操作 carousels_ser = CarouselSer(carousels,many=True) return Response(carousels_ser.data) 使用序列化的增删改查操作12345678910111213141516171819202122232425262728293031323334353637383940#url： path('getcarousel/',GetCarousel.as_view()),class GetCarousel(APIView): #查询操作 def get(self,request): #读库 carousels = Carousel.objects.all() #序列化操作 carousels_ser = CarouselSer(carousels,many=True) return Response(&#123;'data':carousels_ser.data&#125;) #添加操作 def post(self,request): name = request.data.get('name',None) src = request.data.get('link',None) img = request.data.get('imgs',None) ser = Carousel.objects.filter(name=name).first() if ser: return Response(&#123;'msg':'幻灯片已存在'&#125;) carousel = Carousel(name=name,src=src,img=img) carousel.save() #保存入库 return Response(&#123;'code': 200, 'msg': '添加成功'&#125;) #删除操作 def delete(self,request): id = request.GET.get('id',None) Carousel.objects.filter(id=id).delete() return Response(&#123;'code': 200, 'msg': '删除成功'&#125;) #修改操作 def put(self,request): id = request.data.get('id',None) name = request.data.get('name',None) src = request.data.get('link',None) img = request.data.get('imgs',None) car = Carousel.objects.filter(id=id).first() car.name = name car.src = src car.img = img car.save() return Response(&#123;'code':200, 'msg': '修改成功'&#125;) 注意12345rest_framework自带增删改查四种方法查询：get：Carousel.objects.all() ---&gt;method:'GET'增加：post：carousel.save() ---&gt;method:'POST(data)',request.data.get()删除：delete：Carousel.objects.filter(id=id).delete() ---&gt;method:'DELETE(params)',request.GET.get()修改：put：carousel.save() ---&gt;method:'PUT(data)',request.data.get() vue代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;template&gt; &lt;div&gt; &lt;center&gt; &lt;table border=\"1\" style=\"text-align: center;\"&gt; &lt;tr&gt; &lt;td&gt; 名称 &lt;/td&gt; &lt;td&gt; 链接 &lt;/td&gt; &lt;td&gt; 图片 &lt;/td&gt; &lt;td&gt; 添加 &lt;/td&gt; &lt;td&gt; 修改 &lt;/td&gt; &lt;td&gt; 删除 &lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in lunbo_list\" :key=\"index\"&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &#123;&#123;item.name&#125;&#125; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;a :href=\"item.src\" target=\"_black\"&gt;&#123;&#123;item.src&#125;&#125;&lt;/a&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;img :src=\"item.img\" alt=\"\"&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"green\" @click=\"put_lunbo(item.id)\"&gt;修改&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;td&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"red\" @click=\"del_lunbo(item.id)\"&gt;删除&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; name：&lt;input type=\"text\" v-model=\"name\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; img：&lt;input type=\"text\" v-model=\"imgs\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; src：&lt;input type=\"text\" v-model=\"link\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;br&gt; &lt;tr&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"blue\" @click=\"add_lunbo\"&gt;添加&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/tr&gt; &lt;/table&gt; &lt;/table&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; name：&lt;input type=\"text\" v-model=\"name\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; img：&lt;input type=\"text\" v-model=\"imgs\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; src：&lt;input type=\"text\" v-model=\"link\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;br&gt; &lt;tr&gt; &amp;emsp;&amp;emsp; &lt;Button color=\"blue\" @click=\"put_lunbo1\"&gt;修改&lt;/Button&gt; &amp;emsp;&amp;emsp; &lt;/tr&gt; &lt;/table&gt; &lt;/center&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; lunbo_list:[], name:\"\", link:\"\", imgs:\"\", &#125; &#125;, mounted() &#123; this.lunbo(); &#125;, methods: &#123; lunbo()&#123; this.axios(&#123; url:'http://localhost:8000/getcarousel/', method:'GET', &#125;).then(resp=&gt;&#123; console.log(resp) this.lunbo_list = resp.data.data &#125;) &#125;, //增加 add_lunbo()&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'POST', data:&#123; name:this.name, link:this.link, imgs:this.imgs, &#125; &#125;).then(resp=&gt;&#123; console.log(resp) this.$router.go(0) &#125;) &#125;, //删除 del_lunbo(id)&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'DELETE', params:&#123; id:id &#125; &#125;).then(resp=&gt;&#123; console.log(resp) alert(resp.data.msg) this.$router.go(0) &#125;) &#125;, //修改跳转 put_lunbo(id)&#123; //网页跳转传递id this.$router.push(&#123;'path':'/my_lunbo',query:&#123;'aid':id&#125;&#125;) &#125;, //修改 put_lunbo1()&#123; this.axios(&#123; url:'http://127.0.0.1:8000/getcarousel/', method:'PUT',//指定修改方法 data:&#123; id:this.$route.query.aid, name:this.name, link:this.link, imgs:this.imgs, &#125; &#125;).then(resp=&gt;&#123; console.log(resp) alert(resp.data.msg) this.$router.go(0) &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;img&#123; width: 100px; height: 100px;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'Django中间件'","slug":"day13-django中间件","date":"2020-05-07T18:46:11.000Z","updated":"2020-06-06T07:42:12.675Z","comments":true,"path":"2020/05/08/day13-django中间件/","link":"","permalink":"http://www.okwzh.cn/2020/05/08/day13-django%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"django的生命周期流程图中间件位于web服务端与url路由层之间 中间件的响应流程：当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。","text":"django的生命周期流程图中间件位于web服务端与url路由层之间 中间件的响应流程：当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。 中间件的五个方法1234567891011121314151617181920212223# 导包from django.utils.deprecation import MiddlewareMixin #中间件class My_MiddlewareMixin(MiddlewareMixin): # 请求之前 def process_request(self, request): pass # 视图渲染之前 def process_view(self, request, view_func, view_args, view_kwargs): pass # 该方法对视图函数返回值有要求，必须是一个含有render方法类的对象，才会执行此方法 def process_template_response(self, request, response): pass def process_exception(self, request, exception): pass # 返回之前 def process_response(self, request, response): # 注意：response需要使用return返回，不然报错 return response process_view的参数12345678# 该方法有四个参数# request是HttpRequest对象。# view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）# view_args是将传递给视图的位置参数的列表（无名分组分过来的值）.# view_kwargs是将传递给视图的关键字参数的字典（有名分组分过来的值）。 view_args和view_kwargs都不包含第一个视图参数（request）。# Django会在调用视图函数之前调用process_view方法。def process_view(self, request, view_func, view_args, view_kwargs): pass process_response错误：123456 if response.get('X-Frame-Options') is not None:AttributeError: 'NoneType' object has no attribute 'get'# 原因：就是没有返回response# 解决def process_response(self, request, response): return response 定义中间件之后在settings中注册中间件12345678910111213MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', #这里是新增的中间件 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', #加载自定义中间件 文件夹名.文件名.类名 # 'myapp.views.MyMiddleware', 'myapp.md_user.My_MiddlewareMixin',] 使用django原生Httpresponse返回Json格式123456789def process_request(self, request): # 第一种： # content_type=\"application/json\"声明json类型 # indent=4四个空格，美观 # ensure_ascii=False不使用ascii编码，输出中文 return Httpresponse(json.dumps(&#123;'message':'您的秘钥无权限'&#125;,indent=4,ensure_ascii=False),content_type=\"application/json\") # 第二种： # json_dumps_params=dict return JsonResponse(&#123;'message':'您的秘钥无权限'&#125;,safe=False,json_dumps_params=(&#123;'ensure_ascii':False,'indent':4&#125;)) 因为每次请求都要走中间件，所以针对路由判断是否走中间件1234def process_request(self, request): # 获取路由 if request.path_info.startswith('/userinfo/'): return Httpresponse(json.dumps(&#123;'message':'您的秘钥无权限'&#125;,indent=4,ensure_ascii=False),content_type=\"application/json\")","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"'第三方登录-钉钉登录'","slug":"day08-第三方登录-钉钉登录","date":"2020-04-28T05:10:38.000Z","updated":"2020-06-06T07:57:39.608Z","comments":true,"path":"2020/04/28/day08-第三方登录-钉钉登录/","link":"","permalink":"http://www.okwzh.cn/2020/04/28/day08-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-%E9%92%89%E9%92%89%E7%99%BB%E5%BD%95/","excerpt":"钉钉企业注册：点击跳转 官方文档：点击跳转 悦哥钉钉登录博客：点击查看","text":"钉钉企业注册：点击跳转 官方文档：点击跳转 悦哥钉钉登录博客：点击查看 钉钉登录1.注册钉钉企业 2.登录企业后台管理 3.选择应用开发 4.移动接入应用-&gt;登录 5.创建扫码登录应用授权 6.获取创建以后企业应用的appid,appsecret,回调域名 代码示例12345678910urls：path('ding_url/',ding_login),#登录顶顶def ding_login(request): #钉钉应用的appid appid = 'dingoab7edavvvtdcwqcra' # 钉钉应用的回调地址 redirect_uri = 'http://127.0.0.1:8000/callback/' #重定向到 return redirect('https://oapi.dingtalk.com/connect/qrconnect?appid=' +appid+'&amp;response_type=code&amp;scope=snsapi_login&amp;state=STATE&amp;redirect_uri='+redirect_uri) 7.钉钉会将code返回到回调网址中因为钉钉只有java和php的sdk,所以使用hmac加密自己写sdk 123456789101112131415161718192021222324252627282930313233343536373839urls：path('callback/',ding_back),#构造钉钉对调方法。def ding_back(request): #获取code code = request.GET.get('code',None) print('code是：%s'%code) #构造时间戳 t = time.time() timestamp = str(int(round(t*1000))) print('时间：',timestamp) #URL签名参数说明 #钉钉的appSecret appSecret = '8F3q2UmU-2ljILNJAtodsnFaLllpMEioNWI5GRtnoz5OyubMYbiTxlVC3yrPmHiE' #构造签名 signature = base64.b64encode(hmac.new(appSecret.encode('utf-8'),timestamp.encode('utf-8'),digestmod=sha256).digest()) #请求接口，换取用户名 payload = &#123;'tmp_auth_code':code&#125; headers = &#123;'Content-Type':'application/json'&#125; res = requests.post('https://oapi.dingtalk.com/sns/getuserinfo_bycode?' 'accessKey=dingoab7edavvvtdcwqcra&amp;timestamp='+timestamp+ '&amp;signature='+urllib.parse.quote(signature.decode('utf-8')),headers=headers,data=json.dumps(payload)) res_dict = json.loads(res.text) print(res_dict) username = str(res_dict['user_info']['nick']) user = User.objects.filter(username=username).first() if user: #数据库有该用户名，直接登录 user.username = username print('已经登陆过，用户名',username) else: #没有登录,注册 user = User(username=username) user.save() print('首次注册，用户名',username) return redirect('http://localhost:8080/?username='+username) # return HttpResponse(res.text)","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"第三方登录-微博登录","slug":"day08-第三方登录-微博登录","date":"2020-04-28T03:24:55.000Z","updated":"2020-06-06T07:49:34.286Z","comments":true,"path":"2020/04/28/day08-第三方登录-微博登录/","link":"","permalink":"http://www.okwzh.cn/2020/04/28/day08-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95-%E5%BE%AE%E5%8D%9A%E7%99%BB%E5%BD%95/","excerpt":"微博登录思维导图","text":"微博登录思维导图 在微博创建应用1.第一步2.第二步3.第三步4.第四步5.第五步6.第六步 代码示例vue代码 123456789101112131415161718192021222324252627282930&lt;template&gt;&lt;div&gt;&lt;img :src=\"wb_src\" alt=\"点击跳转微博第三方登录\" @click=\"sina\" class=\"imgcode\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; //微博登录url //图片路径 wb_src:'http://127.0.0.1:8000/static/sina.png', &#125; &#125;, methods:&#123; //微博第三方登录 sina()&#123; //拼接url //App Key let client_id = 2731357014; //授权回调页 let redirect_uri = 'http://127.0.0.1:8000/md_admin/weibo'; // //请求url let url = 'https://api.weibo.com/oauth2/authorize?client_id='+client_id+'&amp;redirect_uri='+redirect_uri; // //跳转微博登录页,//返回code，然后后端去接收 window.location.href = url &#125; &#125; &#125; django代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950urls路径配置：path('md_admin/weibo/',wb_back),#新浪微博回调方法def wb_back(request): #接受参数 code = request.GET.get('code',None) print('code是%s'%code) #定义token的获取地址 url = 'https://api.weibo.com/oauth2/access_token' #定义参数 data = &#123; 'client_id':'2731357014',#App Key 'client_secret':'3eb11995fdd72c3b33b3971caac21ffe',#App Secret 'grant_type':'authorization_code',#类型 'code':code,#获取到的code 'redirect_uri':'http://127.0.0.1:8000/md_admin/weibo' &#125; re = requests.post(url=url,data=data) print('re的json是：',re.json()) #换取新浪微博用户昵称 weibo_url = 'https://api.weibo.com/2/users/show.json' params = &#123; 'access_token':re.json()['access_token'], 'uid':re.json()['uid'] &#125; res = requests.get(url=weibo_url,params=params) print('res的json是：',res.json()) print(res.json()) #定义新浪id和用户id sina_id = '' user_id = '' #判断是否使用新浪微博登陆过 user = User.objects.filter(username=str(res.json()['name'])).first() if user: #代表该账号曾经登陆过 sina_id = user.username user_id = user.id else: #首次登录,入库 user = User(username=str(res.json()['name']),password=\"\") user.save() user = User.objects.filter(username=str(res.json()['name'])).first() sina_id = user.username user_id = user.id print('用户是：',sina_id,user_id) #重定向到首页 return redirect('http://127.0.0.1:8080?sina_id='+str(sina_id)+'&amp;user_id='+str(user_id)) # return HttpResponse('回调成功') 关于错误123今日写微博登录犯了一个很典型的错误: 就是单词打错：所有的client都拼写成了clinet 因为是在访问url，所以报了一个'请求不合法错误'","categories":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"}]},{"title":"项目目录","slug":"day02项目目录","date":"2020-04-20T23:55:29.000Z","updated":"2020-06-02T09:05:19.935Z","comments":true,"path":"2020/04/21/day02项目目录/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/","excerpt":"vue有关项目目录","text":"vue有关项目目录 vue的项目目录1234567891011121314151617181920212223build:打包文件config:配置文件 dev.env.js:开发环境变量 index.js:生产环境变量 prod.env.js:灰度环境dist:打包之后存放的文件node_modules:安装的依赖，配置文件,基于package.json下载(该文件不能提交到仓库,需要加入.gitignore).gitignore:存放不需要上传仓库的文件package.json:读取存放依赖，配置等信息 heyui:网页样式 js-mds:加密 style-loader:样式 vue:vue本体 vue-drag-verify:验证码 vue-router:路由components:组件文件夹router&#x2F;index.js:路由 path：路径url name：命名空间 components:导包组件 mode：&#39;history&#39; 取消hash风格的#App.vue：渲染组件main.js：入口文件，vue的组件，实例等都存在这里 hugo的项目目录123456789101112131415161718archetypes:文本配置文件content:生成的md文档data:数据文件夹layouts:布局public:打包文件resources:资源static:静态文件thems:主题config.homl:网站配置文件 baseURL:线上&#x2F;线下url languageCode:语言 title:标题 theme:主题 params：简介和描述 description:简介 themColor:博客主题颜色修改主题颜色：在themes--&gt;hyde--&gt;static--&gt;css--&gt;hyde.css中改颜色(可以自定义主题和颜色)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]},{"title":"Vue启动和命令","slug":"day02vue启动和命令","date":"2020-04-20T23:03:21.000Z","updated":"2020-06-02T09:11:22.987Z","comments":true,"path":"2020/04/21/day02vue启动和命令/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02vue%E5%90%AF%E5%8A%A8%E5%92%8C%E5%91%BD%E4%BB%A4/","excerpt":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0)","text":"配置node.js 12345678配置node.js： 1.node官网：https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F; 2.下载需要的版本---&gt;图1 3.下载成功，开始安装 4.在环境变量中配置node查询node是否启动和环境变量有无问题 命令：node -v (v13.3.0) 三大框架(三大框架都是基于node)1234567891011React： 1 自组件重复渲染问题需要手动优化 2 可以使用redux进行状态管理，函数式，不可变，模式化，时间旅行 3 可使用JSX，完全的javascript能力 4更繁荣的社区生态Vue： 1 可使用JSX，但推荐使用模版语言而不是JSX 2 学习曲线平缓Angular： 1 完善的MV框架，包含模版，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能 2 typescript 3 脏检查，对脏数据的检查，比较UI和后台的数据是否一致 安装依赖(npm)12345678910111213npm： 1.npm官网：https:&#x2F;&#x2F;www.npmjs.com&#x2F; 2.下载安装npm 3.给npm配置环境变量检查npm： 命令：npm -v (6.14.4)关于npm命令： 1.npm默认源是github，因为是外网，所以我们要改源（淘宝源）。命令： npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org 2.查看npm配置：npm config list 3.当npm版本过低，更新版本：npm install -g npm vue1234567891011121314151617181920vue的中文文档：https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html关于vue命令： 1.清空本地缓存：npm cache clean --force 1.在vue中安装依赖&#x2F;配置文件：npm install 2.启动vue：npm run dev 退出：ctrl+cvue依赖： npm install axios --save npm install style-loader —-save npm install heyui --save npm install js-md5 --save关于vue服务启动失败： 1.关掉命令行，退到上一级目录，手动删除node_modules,然后npm install 2.下载rimarf命令：npm install rimraf -g 删除node_modules命令：rimraf node_modules (图2) #使用前提，npm需要是新版本 #优先使用第二个理由：第一个手动删除需要花费大量时间，删除进度缓慢","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"}]},{"title":"环境变量的配置","slug":"day02环境变量","date":"2020-04-20T18:58:38.000Z","updated":"2020-06-02T09:14:40.885Z","comments":true,"path":"2020/04/21/day02环境变量/","link":"","permalink":"http://www.okwzh.cn/2020/04/21/day02%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"环境变量的配置1.找到此电脑","text":"环境变量的配置1.找到此电脑 2.点击右键–&gt;属性 3.点击高级系统设置 4.点击环境变量 5.选择用户变量或者系统变量，点击path，点击编辑 6.点击新建，然后输入需要配置环境变量的路径，一般情况下在bin目录（或者在cmd下） 7.编辑好路径之后，点击确定，再点击确定。然后退出环境变量，确保更改成功。8.ok","categories":[],"tags":[]}],"categories":[{"name":"又拍云","slug":"又拍云","permalink":"http://www.okwzh.cn/categories/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"协议","slug":"协议","permalink":"http://www.okwzh.cn/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/categories/django/"},{"name":"redis","slug":"redis","permalink":"http://www.okwzh.cn/categories/redis/"},{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/categories/git/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.okwzh.cn/tags/python/"},{"name":"算法","slug":"算法","permalink":"http://www.okwzh.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"vue","slug":"vue","permalink":"http://www.okwzh.cn/tags/vue/"},{"name":"js","slug":"js","permalink":"http://www.okwzh.cn/tags/js/"},{"name":"id","slug":"id","permalink":"http://www.okwzh.cn/tags/id/"},{"name":"又拍云","slug":"又拍云","permalink":"http://www.okwzh.cn/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"异步","slug":"异步","permalink":"http://www.okwzh.cn/tags/%E5%BC%82%E6%AD%A5/"},{"name":"多线程","slug":"多线程","permalink":"http://www.okwzh.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"协议","slug":"协议","permalink":"http://www.okwzh.cn/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"状态码","slug":"状态码","permalink":"http://www.okwzh.cn/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"请求方法","slug":"请求方法","permalink":"http://www.okwzh.cn/tags/%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"},{"name":"django","slug":"django","permalink":"http://www.okwzh.cn/tags/django/"},{"name":"hexo博客","slug":"hexo博客","permalink":"http://www.okwzh.cn/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"redis","slug":"redis","permalink":"http://www.okwzh.cn/tags/redis/"},{"name":"celery","slug":"celery","permalink":"http://www.okwzh.cn/tags/celery/"},{"name":"git","slug":"git","permalink":"http://www.okwzh.cn/tags/git/"}]}